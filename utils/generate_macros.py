import os
import textwrap
import argparse


class Generator(object):

    max_args = 125  # MSVC max is 127 - 2 for N & VA_ARGS in FOR signature
    comment = '//'
    disclaimer = [
        "This code is generated by generate_macros.py and should not be",
        "modified directly"
    ]
    wrapsize = 70
    border = 70 * '/'
    escape = ' \\'

    def __init__(self, args):
        self.args = args

    @property
    def header(self):
        return [self.comment + ' ' + x for x in self.disclaimer]

    def generate(self):
        lines = []
        lines += self.generate_inc()
        lines += self.generate_dec()
        lines += self.generate_get_args_after()
        lines += self.generate_get_args_before()
        lines += self.generate_get_arg()
        lines += self.generate_for_each()
        lines += self.generate_nargs()
        lines += self.generate_test()
        self.write(lines)

    def begin_section(self, name, description=[]):
        if isinstance(description, str):
            description = textwrap.wrap(description, width=self.wrapsize)
        out = [self.border, self.comment + ' ' + name]
        out += [self.comment + '   ' + x for x in description]
        out += [self.border]
        return out

    def end_section(self, lines):
        return lines + ['']

    def define(self, name, args='', va_args=False, body='',
               dont_wrap=False):
        out = []
        if va_args and not isinstance(args, list):
            args = []
        if isinstance(args, list):
            if va_args:
                args = args + ['...']
            args = '(' + ', '.join(args) + ')'
        else:
            args = ''
        out += [
            f'#define {name}{args} '
        ]
        if ((isinstance(body, str) and (not dont_wrap)
             and (len(out[-1]) + len(body)) > self.wrapsize)):
            body = [body]
        if isinstance(body, list):
            out[-1] += self.escape
            out += ['  ' + x + self.escape for x in body[:-1]]
            out.append('  ' + body[-1])
        else:
            out[-1] += body
        # if include_utils:
        #     out += self.define_N(name, args=args, va_args=va_args)
        #     out += self.define_defered(name)
        return out

    def define_defered(self, name):
        out = self.define(f'{name}_DEFERED', args=[], body=name)
        out += self.define_expanded(name)
        return out

    def define_expanded(self, name):
        return self.define(f'{name}_EXPANDED', va_args=True,
                           body=f'{name}(__VA_ARGS__)')

    def define_count(self, name, args='', name_N=None, name_C=None,
                     body_C=None, body_N=None, dont_define_N=False,
                     no_defered=False, name_NARGS='NARGS',
                     include_unsafe=False, no_defered_N=None):
        args_call = list(args) if isinstance(args, list) else []
        args_call = [
            f'{name_NARGS}(__VA_ARGS__)'
        ] + args_call + ['__VA_ARGS__']
        if name_N is None:
            name_N = f'{name}_N'
        if name_C is None:
            name_C = name
            if name_N == name:
                name_C += '_'
        if no_defered_N is None:
            no_defered_N = no_defered
        assert name_C != name_N
        if body_C is None:
            body_C = f'{name_N}({", ".join(args_call)})'
        out = self.define(name_C, args=args, va_args=True, body=body_C)
        if not no_defered:
            out += self.define_defered(name_C)
        if not dont_define_N:
            out += self.define_N(name, args=args, va_args=True,
                                 no_suffix=True, name_N=name_N,
                                 body=body_N, no_defered=no_defered_N)
        if include_unsafe:
            out += self.define_count(
                name, args=args, name_N=name_N,
                name_C=f'{name_C}_UNSAFE',
                body_N=body_N, name_NARGS=f'{name_NARGS}_UNSAFE',
                dont_define_N=True, no_defered=no_defered,
                no_defered_N=no_defered_N,
            )
        return out

    def define_N(self, name, args='', va_args=False, no_suffix=False,
                 name_N=None, body=None, no_defered=False, pad=False):
        pad = False
        if body is None:
            body = f'CONCATENATE_MAX({name}_, N)'
            if isinstance(args, list) or va_args:
                args_call = list(args) if isinstance(args, list) else []
                if va_args:
                    args_call += ['__VA_ARGS__']
                    if pad:
                        args_call += ['~']
                body += '(' + ', '.join(args_call) + ')'
        args = list(args) if isinstance(args, list) else []
        args.insert(0, 'N')
        if name_N is None:
            name_N = name
            if not no_suffix:
                name_N += '_N'
        out = self.define(name_N, args=args, va_args=va_args, body=body)
        if not no_defered:
            out += self.define_defered(name_N)
        return out

    def generate_inc(self):
        lines = self.begin_section("INC", "Increment an integer")
        lines += self.define('INC_MAX', body=str(self.args.max_iter))
        lines += self.define_N('INC', no_suffix=True)
        lines += [
            f'#define INC_{x} {x + 1}' for x in range(self.args.max_iter)
        ]
        return self.end_section(lines)

    def generate_dec(self):
        lines = self.begin_section("DEC", "Decrement an integer")
        lines += [f'#define DEC_MAX {self.args.max_iter}']
        lines += self.define_N('DEC', no_suffix=True)
        lines += [
            '#define DEC_0 0'
        ]
        lines += [
            f'#define DEC_{x + 1} {x}' for x in range(self.args.max_iter)
        ]
        return self.end_section(lines)

    def generate_get_args_after(self):
        lines = self.begin_section(
            'GET_ARGS_AFTER',
            "Get the arguments after Nth argument "
            "(zero-indexed, inclusive)"
        )
        lines += self.define_N('GET_ARGS_AFTER', va_args=True)
        body = 'GET_ARG_N(N, CONCATENATE(GET_ARGS_AFTER_, M)(__VA_ARGS__))'
        lines += self.define('GET_ARG_N_AFTER_M', args=['M', 'N'],
                             va_args=True, body=body)
        for i in [10, 100, 110]:
            lines += self.define(
                f'GET_ARG_N_AFTER_{i}', args=['N'], va_args=True,
                body=f'GET_ARG_N_AFTER_M({i}, N, __VA_ARGS__)'
            )
        for i in range(0, 11):
            lines += self.define(f'GET_ARGS_AFTER_{i}',
                                 args=[f'_{x}' for x in range(i)],
                                 va_args=True,
                                 body='__VA_ARGS__')
        for i in range(11, self.args.max_iter):
            base = 10 * (i // 10)
            rem = i - base
            if rem:
                body = (
                    f'CALL_MACRO(GET_ARGS_AFTER_{rem}, '
                    f'GET_ARGS_AFTER_{base}(__VA_ARGS__))'
                )
            else:
                body = (
                    f'CALL_MACRO(GET_ARGS_AFTER_10, '
                    f'GET_ARGS_AFTER_{base - 10}(__VA_ARGS__))'
                )
            lines += self.define(f'GET_ARGS_AFTER_{i}', va_args=True,
                                 body=body)
        return self.end_section(lines)

    def generate_get_args_before(self):
        lines = self.begin_section(
            'GET_ARGS_BEFORE',
            "Get the arguments before Nth argument "
            "(zero-indexed, exclusive)"
        )
        lines += self.define_N('GET_ARGS_BEFORE', va_args=True,
                               pad=True)
        body = (
            'GET_ARG_N_BEFORE_END(N, CONCATENATE(GET_ARGS_BEFORE_, M)'
            '(__VA_ARGS__, ~))'
        )
        lines += self.define('GET_ARG_N_BEFORE_M', args=['M', 'N'],
                             va_args=True, body=body)
        for i in range(1, 11):
            args = [f'_{x}' for x in range(i)]
            lines += self.define(f'GET_ARGS_BEFORE_{i}',
                                 args=args, va_args=True,
                                 body=', '.join(args))
        for i in range(11, self.args.max_iter):
            base = 10 * (i // 10)
            rem = i - base
            if rem:
                body = (
                    f'GET_ARGS_BEFORE_{base}(__VA_ARGS__)'
                    f', CALL_MACRO(GET_ARGS_BEFORE_{rem}, '
                    f'GET_ARGS_AFTER_{base}(__VA_ARGS__), ~)'
                )
            else:
                body = (
                    f'GET_ARGS_BEFORE_{base - 10}(__VA_ARGS__)'
                    f', CALL_MACRO(GET_ARGS_BEFORE_{10}, '
                    f'GET_ARGS_AFTER_{base - 10}(__VA_ARGS__), ~)'
                )
            lines += self.define(f'GET_ARGS_BEFORE_{i}', va_args=True,
                                 body=body)
        return self.end_section(lines)

    def generate_get_arg(self):
        lines = self.begin_section(
            'GET_ARG', "Get the Nth argument (zero indexed)"
        )
        lines += self.define_N('GET_ARG', va_args=True, pad=True)
        for i in range(10):
            args = [f'_{x}' for x in range(i + 1)]
            lines += self.define(f'GET_ARG_{i}',
                                 args=args, va_args=True,
                                 body=f'_{i}')
        for i in range(10, self.args.max_iter):
            base = 10 * (i // 10)
            rem = i - base
            body = (
                f'CALL_MACRO(GET_ARG_{rem}, '
                f'GET_ARGS_AFTER_{base}(__VA_ARGS__))'
            )
            lines += self.define(f'GET_ARG_{i}', va_args=True,
                                 body=body)
        return self.end_section(lines)

    def generate_for_each(self):
        name = 'FOR_EACH_DIFF_CALLERS'
        name_N = f'{name}_'
        lines = self.begin_section(
            name,
            ('Call a macro with arguments for each of the variable '
             'arguments')
        )
        args = ['what', 'caller', 'caller0', 'sep', 'args']
        args_x = args + ['x']
        args_same_caller = [x for x in args if x != 'caller0']
        call_args_same_caller = (
            ['N']
            + [x if x != 'caller0' else 'caller' for x in args]
            + ['__VA_ARGS__']
        )
        lines += self.define_count(
            name, args=args, name_N=name_N, include_unsafe=True,
            no_defered_N=True,
        )
        lines += self.define_count(
            'FOR_EACH', args=args_same_caller,
            name_N='FOR_EACH_', name_C='FOR_EACH_GENERIC',
            body_N=f'{name_N}({", ".join(call_args_same_caller)})',
            include_unsafe=True, no_defered_N=True,
        )
        lines += self.define(f'{name}_0', va_args=True)
        lines += self.define(f'{name}_1', args=args_x,
                             body='caller0(what, args, x)')
        for i in range(2, self.args.max_iter):
            body = [
                'caller(what, args, x)sep()',
                (f'{name}_{i - 1}'
                 f'({", ".join(args)}, __VA_ARGS__)'),
            ]
            lines += self.define(f'{name}_{i}', args=args_x,
                                 va_args=True, body=body)
        return self.end_section(lines)

    def define_return_N(self, N, name=None):
        if name is None:
            name = f'NARGS_ARG_{N}'
        lines = self.define(
            name, va_args=True, body='N',
            args=([f'_{x + 1}' for x in range(N)] + ['N']),
        )
        return lines

    def generate_nargs(self):
        lines = self.begin_section(
            'NARGS', 'Utilities for counting macro arguments'
        )
        # lines += ['#if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL']
        lines += self.define('NARGS_MAX', body=str(self.max_args))
        # lines += ['#endif']
        lines += self.define_return_N(self.max_args,
                                      name='NARGS_ARG_N')
        lines += self.define_return_N(1)
        lines += self.define(
            'NARGS_REMAINDER', va_args=True, body='__VA_ARGS__',
            args=[f'_{x + 1}' for x in range(self.max_args)]
        )
        lines += self.define(
            'NARGS_REVERSE_SEQ_N', args=[],
            body=', '.join([str(x) for x in range(self.max_args, -1, -1)])
        )
        lines += self.define(
            'NARGS_FORWARD_SEQ_N', args=[],
            body=', '.join([str(x) for x in range(self.max_args + 1)])
        )
        lines += self.define(
            'NARGS_ZEROS', args=[],
            body=', '.join(self.args.max_iter * ['0'])
        )
        lines += self.define(
            'NARGS_ONES', args=[],
            body=', '.join(self.args.max_iter * ['1'])
        )
        lines += self.define(
            'NARGS_EMPTY', args=[],
            body=', '.join(self.args.max_iter * [' '])
        )
        lines += self.define(
            'NARGS_FLAGS', args=[],
            body=', '.join(self.args.max_iter * ['UNIQUE_FLAG'])
        )
        return self.end_section(lines)

    def generate_test(self):
        lines = ['#ifdef DO_TEST_MACROS_PREPROCESS']
        lines += self.begin_section(
            "TESTING", 'Utilities for testing macros'
        )
        lines += self.define(
            f'TEST_SEQ_{self.max_args}',
            body=', '.join([str(x) for x in range(self.max_args)])
        )
        lines += self.define('TEST_SEQ_MAX_ARGS',
                             body=f'TEST_SEQ_{self.max_args}')
        lines += self.define(
            f'TEST_SEQ_{self.max_args + 1}',
            body=', '.join([str(x) for x in range(self.max_args + 1)])
        )
        lines += self.define('TEST_SEQ_MAX_ARGS_PLUS1',
                             body=f'TEST_SEQ_{self.max_args + 1}')
        lines += self.define(
            f'TEST_SEQ_{self.args.max_iter}',
            body=', '.join([str(x) for x in range(self.args.max_iter)])
        )
        lines += self.define('TEST_SEQ_MAX_ITER',
                             body=f'TEST_SEQ_{self.args.max_iter}')
        lines += self.define(
            'DISPLAY_MACRO_TEST', args=['name', 'exp', 'expr', 'str'],
            body='name[exp][expr] -> str',
        )
        lines += self.define('MACRO_TEST_ERROR',
                             body=['MACRO_TEST_ERROR ## ('])
        lines += self.define('MACRO_TEST_RESULT_0', va_args=True,
                             body=['MACRO_TEST_ERROR; ',
                                   'DISPLAY_MACRO_TEST(__VA_ARGS__)'])
        lines += ['#ifdef SHOW_PASSED_MACRO_TESTS']
        lines += self.define('MACRO_TEST_RESULT_1', va_args=True,
                             body='DISPLAY_MACRO_TEST(__VA_ARGS__)')
        lines += ['#else // SHOW_PASSED_MACRO_TESTS']
        lines += self.define('MACRO_TEST_RESULT_1', va_args=True,
                             body='')
        lines += ['#endif // SHOW_PASSED_MACRO_TESTS']
        lines += self.define(
            'CHECK_TEST_RESULT', args=['name', 'exp', 'expr', 'str'],
            body=('IF_FUNC(EQUAL(exp, expr), MACRO_TEST_RESULT_)'
                  '(name, exp, expr, str)')
        )
        lines += self.define(
            'MACRO_TEST', args=['name', 'exp', 'expr'],
            body=('CHECK_TEST_RESULT(name, PACK_MACRO(exp), '
                  'PACK_MACRO(expr), #expr)')
        )
        lines += self.define(
            'MACRO_TEST_NOEQ', args=['name', 'exp', 'expr'],
            body=('DISPLAY_MACRO_TEST(name, PACK_MACRO(exp), '
                  'PACK_MACRO(expr), #expr)'),
        )
        lines += self.define(
            'MACRO_TEST_EVAL', args=['name', 'exp', 'expr'],
            body=('DISPLAY_MACRO_TEST(name, PACK_MACRO(exp), '
                  'EVAL(expr), #expr)'),
        )
        lines += ['#endif // DO_TEST_MACROS_PREPROCESS']
        return self.end_section(lines)

    def write(self, lines):
        assert lines
        contents = '\n'.join(self.header + lines)
        if self.args.verbose:
            print(f"{self.args.dst}\n----------------\n{contents}")
        if self.args.dry_run:
            return contents
        if (not self.args.overwrite) and os.path.isfile(self.args.dst):
            raise AssertionError(f"File \'{self.args.dst}\' already "
                                 f"exists")
        with open(self.args.dst, 'w') as fd:
            fd.write(contents)
        return contents


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "Generate header for macro iteration")
    parser.add_argument("dst", type=str,
                        help=("Location where generated file should be "
                              "written"))
    parser.add_argument("--overwrite", action="store_true",
                        help="Overwrite any existing file(s)")
    parser.add_argument("--verbose", action="store_true",
                        help="Display the generated file content")
    parser.add_argument("--dry-run", action="store_true",
                        help="Run without writing any file(s)")
    parser.add_argument("--max-iter", type=int, default=200,
                        help=("Maximum number of arguments that "
                              "iteration macros should allow"))
    parser.add_argument("--include-tests", action="store_true",
                        help="Define macros for generating tests")
    args = parser.parse_args()
    generator = Generator(args)
    generator.generate()
