import os
import glob
import pprint
import argparse


_registry = {'parser': {}, 'generator': {}}


def registered_classes(typename, return_classes=False):
    global _registry
    if return_classes:
        return [v for k, v in _registry[typename].items() if k is not None]
    return [k for k in _registry[typename].keys() if k is not None]


def get_registered_class(typename, name):
    global _registry
    return _registry[typename][name]


def get_registered_value_keys():
    global _registry
    return [v.default_value_key for v in _registry['generator'].values()
            if hasattr(v, 'default_value_key')]


class EnumMeta(type):

    def __new__(meta, name, bases, class_dict):
        cls = type.__new__(meta, name, bases, class_dict)
        global _registry
        if cls._type is not None and cls.name is not None:
            if cls.name in _registry[cls._type]:
                raise AssertionError(f"{cls._type} \'{cls.name}\' "
                                     f"already registered")
            _registry[cls._type][cls.name] = cls
        cls.create_child_classes(cls)
        return cls


class EnumBase(metaclass=EnumMeta):

    _type = None
    name = None
    prefixes = {}
    suffixes = {}
    lowers = {}
    replacements = {}

    def __init__(self, src, kwargs):
        self.src = src
        self._current_keys = {}
        for k in ['prefixes', 'suffixes', 'lowers', 'replacements']:
            if k in kwargs:
                setattr(self, k, kwargs.pop(k))

    @staticmethod
    def create_child_classes(cls):
        pass

    @property
    def current_key(self):
        return self._current_keys.get('k', None)

    def reset_current_keys(self):
        self._current_keys = {}

    def add_enum(self, k):
        self._current_keys = {
            'k': k,
            'kprefix': self.prefixes.get(k, []),
            'ksuffix': self.suffixes.get(k, []),
            'klower': self.lowers.get(k, False),
            'kreplacement': self.replacements.get(k, {}),
            'lastidx': -1,
        }

    def add_member(self, member):
        raise NotImplementedError

    def add_prefix(self, k, v):
        self.prefixes = dict(self.prefixes)
        self.prefixes.setdefault(k, [])
        if v not in self.prefixes[k]:
            self.prefixes[k].append(v)


class EnumParserBase(EnumBase):

    _type = 'parser'
    file_extension = None
    comment = None

    def __init__(self, src, is_regex=False, verbose=False, **kwargs):
        if is_regex:
            src = glob.glob(src)
            assert src
        else:
            src = [src]
        self.param = {}
        super(EnumParserBase, self).__init__(src, kwargs)
        for isrc in sorted(self.src):
            self.parse(isrc, **kwargs)
        if verbose:
            pprint.pprint(self.param)

    def add_enum(self, k):
        super(EnumParserBase, self).add_enum(k)
        self.param.setdefault(k, [])

    def add_member(self, member):
        assert self.current_key is not None
        if 'idx' in member:
            member.setdefault('explicit_idx', True)
        member.setdefault('idx', str(self._current_keys['lastidx']))
        member.setdefault('doc', '')
        member.setdefault('abbr', member['name'])
        for x in self._current_keys['kprefix']:
            member['abbr'] = member['abbr'].split(x)[-1]
        for x in self._current_keys['ksuffix']:
            member['abbr'] = member['abbr'].split(x)[0]
        if self._current_keys['klower']:
            member['abbr'] = member['abbr'].lower()
        member['abbr'] = self._current_keys['kreplacement'].get(
            member['abbr'], member['abbr'])
        if member['name']:
            self.param[self.current_key].append(member)
            self._current_keys['lastidx'] = int(member['idx'])

    def parse(self, src, **kwargs):
        with open(src, 'r') as fd:
            lines = fd.readlines()
        self.parse_lines(lines, src=src, **kwargs)

    def parse_lines(self, lines, **kwargs):
        raise NotImplementedError

    def prefix_by_split(self, split):
        out = {}
        for k, v in self.param.items():
            prefix = k.split(split, 1)[0]
            out[k] = [prefix]
        return out


class EnumGeneratorBase(EnumBase):

    _type = 'generator'
    prefix = []
    suffix = []
    file_prefix = ''
    file_suffix = ''
    file_extension = None
    skip = []
    skip_items = {}
    added_file_classes = {}
    added_section_classes = {}
    explicit_dst = False
    perfile_options = {
        'dst': {
            'type': str,
            'help': "Location where generated file should be written"
        },
        'append': {
            'type': str,
            'choices': ['nothing', 'direct', 'preserved', 'unique'],
            'help': "How data should be appended to the file",
        },
    }
    disclaimer = [
        "This code is generated by generate_enum.py and should not be",
        "modified directly"
    ]
    preserve_marker = [
        "Code after this line will be preserved"
    ]

    def __init__(self, src, dst=None, directory=None, added_files=None,
                 parent=None, child_kws={}, skip_children=False,
                 dont_generate=False, added_sections=None,
                 top_level=False, **kwargs):
        for k in self.perfile_options_keys():
            key = f'{k}_{self.name}'
            if key in kwargs:
                if top_level:
                    kwargs[k] = kwargs.pop(key)
                else:
                    raise AssertionError(f'File specific keyword '
                                         f'argument present: {key}')
            if (k in kwargs) or (not hasattr(self, k)):
                setattr(self, k, kwargs.pop(k, None))
        if dst is None:
            if self.explicit_dst:
                raise ValueError(f"Destination must be provided for "
                                 f"\'{self.name}\' {self._type}")
            assert self.file_suffix or self.file_extension
            src_parts = os.path.split(src.src[0])
            dst = directory if directory else src_parts[0]
            if self.file_prefix:
                dst = os.path.join(dst, self.file_prefix + src_parts[1])
            else:
                dst = os.path.join(dst, src_parts[1])
            if self.file_suffix:
                dst = self.file_suffix.join(os.path.splitext(dst))
            if self.file_extension:
                dst = os.path.splitext(dst)[0] + self.file_extension
        self.basename = os.path.basename(os.path.splitext(dst)[0])[-1]
        self.dst = dst
        self.parent = parent
        self.lines = []
        if added_files is None:
            added_files = {}
        self.added_files = added_files
        if added_sections is None:
            added_sections = {}
        self.added_sections = added_sections
        child_kws = self.extract_child_kws(kwargs, child_kws,
                                           directory=directory,
                                           dont_generate=True)
        super(EnumGeneratorBase, self).__init__(src, kwargs)
        if not skip_children:
            for k, v in self.added_file_classes.items():
                kws = child_kws[v.name]
                if k == 'header' and 'dst' not in kws:
                    kws['dst'] = self.dst.replace(
                        self.file_extension, v.file_extension)
                if k not in self.added_files:
                    self.added_files[k] = v(src, child_kws=child_kws,
                                            parent=self, **kws)
            for k, v in self.added_section_classes.items():
                kws = child_kws[v.name]
                if k not in self.added_sections:
                    self.added_sections[k] = v(src, child_kws=child_kws,
                                               parent=self, **kws)
        self.lines = []
        self.write_kwargs = dict(kwargs, append=self.append)
        if not dont_generate:
            self.do_write()

    @classmethod
    def add_arguments(cls, parser):
        for k, v in cls.perfile_options.items():
            key = f"{k}_{cls.name}"
            dest = v.get('dest', '')
            help_msg = v.get('help', '')
            if help_msg:
                v = dict(v, help=f"{cls.name}: {help_msg}")
            if dest:
                v = dict(v, dest=f"{dest}_{cls.name}")
            parser.add_argument(
                f"--{key.replace('_', '-')}", **v)

    @classmethod
    def get_arguments(cls, args, kwargs, top_level=False):
        for k, v in cls.perfile_options.items():
            if v.get('dest', ''):
                k = v['dest']
            key = f"{k}_{cls.name}"
            val = getattr(args, key, None)
            if val is not None:
                if top_level:
                    kwargs[k] = val
                else:
                    kwargs[key] = val

    @classmethod
    def perfile_options_keys(cls):
        return ['kwargs'] + [
            v.get('dest', k) for k, v in cls.perfile_options.items()]

    @classmethod
    def all_children(cls, return_classes=False):
        if return_classes:
            out = (
                list(cls.added_file_classes.values())
                + list(cls.added_section_classes.values())
            )
        else:
            out = (
                [v.name for v in cls.added_file_classes.values()]
                + [v.name for v in cls.added_section_classes.values()]
            )
        for v in cls.added_file_classes.values():
            out += v.all_children(return_classes=return_classes)
        for v in cls.added_section_classes.values():
            out += v.all_children(return_classes=return_classes)
        return out

    @classmethod
    def extract_child_kws(cls, kwargs, child_kws, **kws_all):
        kwargs_orig = dict(kwargs)
        out = child_kws
        kws_all.update(**child_kws.pop('all', {}))
        for xcls in cls.all_children(return_classes=True):
            x = xcls.name
            out.setdefault(x, {})
            for k in xcls.perfile_options_keys():
                key = f"{k}_{x}"
                if key in kwargs:
                    if k == 'kwargs':
                        out[x].update(**kwargs.pop(key))
                    else:
                        out[x][k] = kwargs.pop(key)
                elif key in kwargs_orig:
                    if k == 'kwargs':
                        out[x].update(**kwargs_orig[key])
                    else:
                        out[x][k] = kwargs_orig[key]
        kws_all = dict(kwargs, **kws_all)
        for x in cls.all_children():
            out[x] = dict(kws_all, **out[x])
        return out

    @property
    def existing_lines(self):
        if os.path.isfile(self.dst):
            with open(self.dst, 'r') as fd:
                return fd.read().splitlines()
        return []

    def get_child(self, k):
        if k in self.added_sections:
            return self.added_sections[k]
        return self.added_files[k]

    def do_generate(self):
        for v in self.added_sections.values():
            v.do_generate()
        for v in self.added_files.values():
            v.do_generate()
        self.lines = self.generate()

    def do_write(self):
        for v in self.added_sections.values():
            v.do_generate()
        for v in self.added_files.values():
            v.do_write()
        return self.write(**self.write_kwargs)

    def write(self, verbose=False, overwrite=False, dry_run=False,
              append=False):
        self.lines = self.generate()
        # if not self.lines:
        #     print(f"No lines to be written to {self.dst}")
        #     return
        lines = [
            self.comment + ' ' + x for x in self.disclaimer
        ] + self.prefix + self.lines + self.suffix
        if append == 'nothing':
            append = False
        if append and os.path.isfile(self.dst):
            existing = self.existing_lines
            if append in [True, 'direct', 'True']:
                lines = existing + lines
            elif append == 'unique':
                for x in lines:
                    if x not in existing:
                        existing.append(x)
                lines = existing
            elif append == 'preserved':
                marker = self.comment + ' ' + self.preserve_marker[0]
                marker_len = len(self.preserve_marker)
                idx_old = existing.index(marker) if marker in existing else -1
                idx_new = lines.index(marker) if marker in lines else -1
                if idx_old != -1:
                    if idx_new != -1:
                        lines = (
                            lines[:(idx_new + marker_len)]
                            + existing[(idx_old + marker_len):]
                            + lines[(idx_new + marker_len):])
                    else:
                        lines += existing[(idx_old + marker_len):]
            else:
                raise NotImplementedError(
                    f"Invalid append value: \'{append}\'")
        contents = '\n'.join(lines) + '\n'
        if verbose:
            print(f"{self.dst}\n----------------\n{contents}")
        if dry_run:
            return
        if (not overwrite) and os.path.isfile(self.dst):
            raise AssertionError(f"{self.name} file {self.dst} "
                                 f"already exists")
        with open(self.dst, 'w') as fd:
            fd.write(contents)

    def max_width(self, members, key='name', func=None):
        if len(members) == 0:
            return 0
        if func is not None:
            width = len(func(max(members, key=lambda x: len(func(x)))))
        elif key == 'name':
            width = len(self.add_member(
                max(members, key=lambda x:
                    len(self.add_member(x, return_name=True))),
                return_name=True))
        else:
            width = len(max(members, key=lambda x:
                            len(x.get(key, ''))).get(key, ''))
        if key == 'idx':
            width += 3
        return width

    def add_member(self, member, return_name=False, add_prefix=None,
                   strip_suffix=None, replace_with_prefix=False,
                   add_enum=False):
        if add_enum:
            self.add_enum(add_enum)
        assert self.current_key is not None
        if isinstance(member, str):
            member = {'name': member}
        name = member['name']
        abbr = member.get('abbr', name)
        if replace_with_prefix and self._current_keys['kprefix']:
            name = ''
        name = self._current_keys['kreplacement'].get(
            name, name)
        if self._current_keys['klower']:
            name = name.lower()
        if not member.get('no_suffix', False):
            for x in self._current_keys['ksuffix']:
                name = name + x
        if not member.get('no_prefix', False):
            for x in self._current_keys['kprefix']:
                name = x + name
        if replace_with_prefix and self._current_keys['kprefix']:
            name = name.rstrip('_')
        if add_prefix:
            name = add_prefix + name
        if strip_suffix:
            assert name.endswith(strip_suffix)
            name = name.rsplit(strip_suffix)[0]
            abbr = abbr.rsplit(strip_suffix)[0]
        if return_name:
            return name
        return dict(member, name=name, abbr=abbr)

    def generate_member(self, x, **kwargs):
        raise NotImplementedError

    def generate_enum(self, name, members, prefix_with_type=False,
                      **kwargs):
        lines = []
        if prefix_with_type:
            self.add_prefix(name, name + '_')
        self.add_enum(name)
        lines += self.generate_item(name, members, **kwargs)
        return lines

    def generate_item(self, name, members, skip_items=[], **kwargs):
        lines = []
        for x in members:
            if x['abbr'] in self.skip_items.get(name, []) + skip_items:
                continue
            x = self.add_member(x)
            lines += self.generate_member(x, **kwargs)
        return lines

    def generate(self, indent='', skip=[], enum_keys=None, **kwargs):
        lines = []
        if enum_keys is None:
            enum_keys = list(self.src.param.keys())
        for k in enum_keys:
            if k in self.skip + skip:
                continue
            self.add_enum(k)
            lines += [indent + x for x in
                      self.generate_item(k, self.src.param[k], **kwargs)]
        return lines


class CMixin:

    comment = "//"
    perfile_options = dict(
        EnumGeneratorBase.perfile_options,
        include_file={
            'action': 'append',
            'dest': 'include_files',
            'help': "File that should be included.",
        },
        namespace={
            'action': 'append',
            'dest': 'namespaces',
            'help': "C++ namespaces that should contain the classes",
        },
    )

    def __init__(self, *args, **kwargs):
        self.root_include_dir = kwargs.pop('root_include_dir', None)
        if not hasattr(self, 'namespaces'):
            self.namespaces = kwargs.pop('namespaces', None)
        if ((self._type == 'generator'
             and (self.namespaces or self.root_include_dir))):
            kwargs.setdefault('child_kws', {})
            kwargs['child_kws'].setdefault('all', {})
            kwargs['child_kws']['all'].setdefault(
                'root_include_dir', self.root_include_dir)
            kwargs['child_kws']['all']['namespaces'] = self.namespaces
        super().__init__(*args, **kwargs)

    @classmethod
    def include_file(cls, x, caller=None, rootdir=None):
        if isinstance(x, EnumGeneratorBase):
            x = x.dst
        elif isinstance(x, EnumParserBase):
            x = x.src
        if rootdir is None and caller is not None:
            rootdir = os.path.commonprefix([x, caller])
        if rootdir is None:
            header_incl = os.path.basename(x)
        else:
            header_incl = os.path.relpath(x, rootdir)
        return [f"#include \"{header_incl}\"", ""]

    @classmethod
    def specialization(cls, lines, spec_param=[], specialize=[],
                       spec_var=None):
        specialization = ''
        if spec_param:
            if specialize:
                if lines is not None:
                    lines += ['template<>']
                specialization = f"<{', '.join(specialize)}>"
            else:
                if spec_var is None:
                    if len(spec_param) == 1:
                        spec_var = ['T']
                    else:
                        spec_var = [
                            f'T{i}' for i in range(len(spec_param))]
                assert len(spec_var) == len(spec_param)
                param = [f"{x} {t}" for x, t in
                         zip(spec_param, spec_var)]
                if lines is not None:
                    lines += [f"template<{', '.join(param)}>"]
        return specialization, spec_var

    def add_include_files(self):
        lines = []
        if self.include_files:
            for x in self.include_files:
                lines += self.include_file(x, caller=self.dst,
                                           rootdir=self.root_include_dir)
            lines += ['']
        return lines

    def include_self(self, caller, rootdir=None):
        if rootdir is None:
            rootdir = self.root_include_dir
        return self.include_file(
            self.dst, caller=caller, rootdir=rootdir)

    def include_header(self, caller=None):
        if caller is None:
            caller = self.dst
        return self.include_file(
            self.get_child('header').dst, caller=caller,
            rootdir=self.root_include_dir)

    def generate(self, indent='', **kwargs):
        lines = []
        lines += self.add_include_files()
        if self.namespaces:
            if self.file_extension in ['.hpp', '.h']:
                for x in self.namespaces:
                    lines += [f"{indent}namespace {x} {{"]
                    indent += 2 * ' '
            else:
                lines += [
                    f"using namespace {'::'.join(self.namespaces)};", ""]
        lines += super().generate(indent=indent, **kwargs)
        if self.namespaces and self.file_extension in ['.hpp', '.h']:
            for x in self.namespaces:
                indent = indent[:(len(indent) - 2)]
                lines += [f"{indent}}}"]
        return lines


class ParamFileParser(EnumParserBase):

    name = 'param'
    comment = '#'
    file_extension = '.txt'
    required_keys = ['name', 'val']
    optional_keys = ['doc', 'val_alt', 'qualifiers']

    def parse(self, src, **kwargs):
        k = os.path.basename(os.path.splitext(src)[0])
        self.add_enum(k)
        out = super(ParamFileParser, self).parse(src, **kwargs)
        self.reset_current_keys()
        return out

    def parse_lines(self, lines, src=None):
        for line in lines:
            # assert '//' not in line
            rem = line.split(self.comment, 1)
            if (not rem[0]) or rem[0].isspace():
                continue
            member = {}
            if len(rem) == 2:
                member['doc'] = rem[1].strip()
                if member['doc'].startswith('['):
                    member['qualifiers'] = member['doc'].split(
                        ']')[0].lstrip('[')
                    qualifiers = {}
                    for x in member['qualifiers'].split(','):
                        val = True
                        if '=' in x:
                            x, val = x.split('=')
                        qualifiers[x.strip().upper()] = val
                    valid_qualifiers = get_registered_value_keys()
                    for k in self.required_keys + self.optional_keys:
                        if k in valid_qualifiers:
                            valid_qualifiers.remove(k)
                    invalid_qualifiers = [
                        x for x in qualifiers.keys()
                        if x not in valid_qualifiers
                    ]
                    if invalid_qualifiers:
                        raise AssertionError(
                            f"Invalid qualifiers: {invalid_qualifiers} "
                            f" (available options: {valid_qualifiers})")
                    member.update(qualifiers)
            rem = rem[0].split()
            member['name'] = rem[0].strip()
            member['val'] = rem[1].strip()
            if len(rem) >= 3:
                member['val_alt'] = rem[2].strip()
            if len(rem) > 3:
                raise AssertionError(f"Line in {src} contains more than "
                                     f"3 values: \"{line}\"")
            for k in self.required_keys:
                if k not in member:
                    raise AssertionError(
                        f"Required key \"{k}\" not parsed from line in "
                        f"{src}: \"{line}\"")
            self.add_member(member)


class CEnumParser(EnumParserBase):

    name = 'c'
    file_extension = '.cpp'

    def parse_lines(self, lines, src=None):
        i = 0
        while i < len(lines):
            if self.current_key is not None:
                if '}' in lines[i]:
                    self.reset_current_keys()
                else:
                    member = {}
                    rem = lines[i].split('//', 1)
                    if len(rem) == 2:
                        member['doc'] = rem[1].strip().rstrip('!<')
                    rem = rem[0].split(',')[0]
                    rem = rem.split("=", 1)
                    if len(rem) == 2:
                        member['idx'] = eval(rem[1].strip().rstrip('LL'))
                    member['name'] = rem[0].strip()
                    self.add_member(member)
            elif lines[i].strip().startswith('enum'):
                k = lines[i].split('enum', 1)[1].split()[0].strip()
                self.add_enum(k)
                while '{' not in lines[i]:
                    i += 1
            i += 1


class CEnumGeneratorBase(CMixin, EnumGeneratorBase):

    file_suffix = '_enum'
    file_extension = '.hpp'
    prefix = [
        '#pragma once',
        '',
    ]


class CEnumGeneratorBaseHeader(CEnumGeneratorBase):

    source_attr = {}
    is_parent = True
    perfile_options = dict(
        CEnumGeneratorBase.perfile_options,
        define_in_header={
            'action': 'store_true', 'default': True,
            'help': "Write the definition in the header.",
        },
        **EnumGeneratorBase.perfile_options,
    )

    @staticmethod
    def create_child_classes(cls):
        EnumGeneratorBase.create_child_classes(cls)
        if cls.name is None or not cls.is_parent:
            return

        class SourceClass(CEnumGeneratorBaseSource):

            name = f"{cls.name}_source"
            file_suffix = cls.file_suffix
            is_parent = False

        for k, v in cls.source_attr.items():
            setattr(SourceClass, k, v)
        cls.added_file_classes = dict(
            cls.added_file_classes,
            source=SourceClass)

    def add_enum(self, *args, **kwargs):
        super(CEnumGeneratorBaseHeader, self).add_enum(*args, **kwargs)
        if not self.is_parent:
            self.parent.add_enum(*args, **kwargs)

    def generate_source_item(self, name, members):
        lines = []
        if not self.define_in_header:
            lines += [self.generate_declaration(name, members)]
            lines[-1] = lines[-1] + ' {'
            lines += [
                '  ' + x for x in self.generate_definition(name, members)]
            lines += ["};", ""]
        return lines

    def generate_source_closing(self, **kwargs):
        return []

    def generate_declaration(self, name, members, for_header=False):
        raise NotImplementedError

    def generate_definition(self, name, members, **kwargs):
        return super(CEnumGeneratorBaseHeader, self).generate_item(
            name, members, **kwargs)

    def generate_item(self, name, members, **kwargs):
        if not self.is_parent:
            assert self.parent
            return self.parent.generate_header_item(name, members, **kwargs)
        lines = []
        if self.define_in_header:
            lines += [self.generate_declaration(name, members) + ' {']
            lines += [
                '  ' + x for x in self.generate_definition(name, members)]
            lines += ["};", ""]
        return lines

    def generate(self, **kwargs):
        lines = super(CEnumGeneratorBaseHeader, self).generate(**kwargs)
        if not self.is_parent:
            assert self.parent
            lines += self.parent.generate_header_closing(**kwargs)
        return lines


class CEnumGeneratorBaseSource(CMixin, EnumGeneratorBase):

    file_extension = '.cpp'
    header_attr = {}
    is_parent = True
    perfile_options = dict(
        CMixin.perfile_options,
        define_in_header={
            'action': 'store_true', 'default': True,
            'help': "Write the definition in the header.",
        },
        docs={
            'type': str,
            'help': "Doc string for enumerator",
        },
        **EnumGeneratorBase.perfile_options,
    )

    @staticmethod
    def create_child_classes(cls):
        EnumGeneratorBase.create_child_classes(cls)
        if cls.name is None or not cls.is_parent:
            return

        class HeaderClass(CEnumGeneratorBaseHeader):

            name = f"{cls.name}_header"
            file_suffix = cls.file_suffix
            is_parent = False

        for k, v in cls.header_attr.items():
            setattr(HeaderClass, k, v)
        cls.added_file_classes = dict(
            cls.added_file_classes,
            header=HeaderClass)

    def generate_docs(self, name):
        return self.docs

    def generate_header_item(self, name, members):
        lines = [self.generate_declaration(name, members,
                                           for_header=True)]
        docs = self.generate_docs(name)
        if self.define_in_header:
            if docs:
                lines = [f'/** {docs} */'] + lines
            lines[-1] = 'inline ' + lines[-1] + ' {'
            lines += [
                '  ' + x for x in self.generate_definition(name, members)]
            lines += ["};", ""]
        else:
            lines[-1] += ';'
            if docs:
                lines[-1] += f'  /**< {docs} */'
        return lines

    def generate_header_closing(self, **kwargs):
        return []

    def generate_declaration(self, name, members, for_header=False):
        raise NotImplementedError

    def generate_definition(self, name, members, **kwargs):
        return super(CEnumGeneratorBaseSource, self).generate_item(
            name, members, **kwargs)

    def generate_item(self, name, members):
        if not self.is_parent:
            assert self.parent
            return self.parent.generate_source_item(name, members)
        lines = []
        if not self.define_in_header:
            lines += [self.generate_declaration(name, members) + ' {']
            lines += [
                '  ' + x for x in self.generate_definition(name, members)]
            lines += ["};", ""]
        return lines

    def generate(self, indent='', **kwargs):
        lines = []
        if not self.define_in_header:
            lines += self.include_header()
        lines += super(CEnumGeneratorBaseSource, self).generate(
            indent=indent, **kwargs)
        if not self.is_parent:
            assert self.parent
            lines += self.parent.generate_source_closing(
                indent=indent, **kwargs)
        return lines


class CEnumGeneratorCollectionBase(CEnumGeneratorBaseSource):

    perfile_options = dict(
        CEnumGeneratorBaseSource.perfile_options,
        collection_name={
            'type': str,
            'help': ("Name that should be used for collection. Defaults "
                     "to class name"),
        },
        function_suffix={
            'type': str,
            'help': ("Suffix that should be added the the end of the "
                     "function for returning the enum collection. "
                     "Defaults to collection_name if provided and class "
                     "name if not."),
        },
        specialize_in_source={
            'action': 'store_true',
            'help': ("Specialize the template to get the collection in "
                     "the source file instead of the header"),
        },
        dont_specialize={
            'action': 'store_true',
            'help': "Don't special the template function",
        },
        is_editable={
            'action': 'store_true',
            'help': "Allow the static collection to be editable",
        },
        value_key={
            'type': str,
            'help': ("Name of key where values controlling the "
                     "collection are stored."),
        },
        secondary_value_key={
            'type': str,
            'help': ("Name of key where values for the collection "
                     "should be taken from if value_key is not "
                     "present."),
        },
    )
    collection_type = None
    default_is_editable = False
    default_value_key = None
    default_secondary_value_key = None
    _default_function_param = {
        'return_type': 'void',
    }
    _utility_functions = [
        'error_prefix', 'print', 'string', 'operator<<',
    ]
    _utility_function_param = {
        'error_prefix': {
        }
    }
    _additional_functions = []
    _editable_functions = [
        'clear', 'add', 'remove', 'addMultiple', 'removeMultiple',
    ]
    _print_prefix = None
    _print_suffix = None

    def __init__(self, *args, **kwargs):
        kwargs.setdefault("collection_name", self.name)
        kwargs.setdefault("function_suffix", kwargs['collection_name'])
        kwargs.setdefault("is_editable", self.default_is_editable)
        kwargs.setdefault("value_key", self.default_value_key)
        kwargs.setdefault("secondary_value_key",
                          self.default_secondary_value_key)
        if kwargs.get('define_in_header', False):
            kwargs['specialize_in_source'] = False
        super(CEnumGeneratorCollectionBase, self).__init__(*args, **kwargs)

    @classmethod
    def create_class(cls, class_name, **kwargs):

        kwargs.setdefault('file_suffix', f"_{class_name}")

        class CEnumGeneratorCollectionCreated(cls):

            name = class_name

        for k, v in kwargs.items():
            setattr(CEnumGeneratorCollectionCreated, k, v)
        for k in list(CEnumGeneratorCollectionCreated.perfile_options.items()):
            if f'default_{k}' in kwargs:
                CEnumGeneratorCollectionCreated.perfile_options[k] = dict(
                    CEnumGeneratorCollectionCreated.perfile_options[k],
                    default=kwargs[f'default_{k}'])
        return CEnumGeneratorCollectionCreated

    @property
    def add_value_args(self):
        return []

    @property
    def utility_functions(self):
        return self._utility_functions

    @property
    def additional_functions(self):
        if self.is_editable:
            return (self._utility_functions
                    + self._additional_functions
                    + self._editable_functions)
        return self._utility_functions + self._additional_functions

    def generate_value(self, x):
        if self.value_key is None:
            raise NotImplementedError
        out = str(x.get(self.value_key, ''))
        if (not out) and self.secondary_value_key is not None:
            out = str(x.get(self.secondary_value_key, ''))
        return out

    def generate_member(self, *args, **kwargs):
        raise NotImplementedError

    def generate_collection_param(self, name, enum_prefix=''):
        return [f'{enum_prefix}{name}']

    def generate_collection_type(self, *args, **kwargs):
        if self.collection_type is None:
            raise NotImplementedError
        param = ', '.join(
            self.generate_collection_param(*args, **kwargs))
        return f"{self.collection_type}<{param}>"

    def generate_declaration(self, name, members, for_header=False,
                             in_class=False, var_name='collection'):
        const = "" if self.is_editable else "const "
        if in_class:
            return (
                f"{const}"
                f"{self.generate_collection_type(name, enum_prefix=in_class)} "
                f"{var_name}")
        func_name = f"{name}_{self.function_suffix}"
        if (not for_header) and self.namespaces:
            func_name = f"{'::'.join(self.namespaces)}::{func_name}"
        func_decl = (
            f"{const}{self.generate_collection_type(name)}& {func_name}()")
        return func_decl

    def generate_definition(self, name, members, var_name='collection',
                            no_return=False, in_class=False,
                            enum_prefix='', function_type='get', **kwargs):
        if in_class:
            no_return = True
            enum_prefix = in_class
        if function_type != 'get':
            return self.generate_additional_method(
                function_type, enum_name=f'{enum_prefix}{name}',
                enum_is_class=in_class, result=var_name,
                no_return=no_return)
        enum_member_prefix = enum_prefix
        if in_class:
            enum_member_prefix += f'SCOPED_ENUM_TYPE({name})'
        static = '' if in_class else 'static '
        const = "" if self.is_editable else "const "
        lines = [
            f"{static}{const}"
            f"{self.generate_collection_type(name, enum_prefix=enum_prefix)} "
            f"{var_name} = {{"
        ]
        width = self.max_width(members) + len(enum_prefix)
        lines += super(
            CEnumGeneratorCollectionBase, self).generate_definition(
                name, members, width=width,
                enum_prefix=enum_member_prefix, **kwargs)
        lines += ["};"]
        if not no_return:
            lines += [f"return {var_name};"]
        return lines

    def generate_specialization(self, name, members, **kwargs):
        lines = []
        if self.dont_specialize:
            return lines
        if self.parent.as_class:
            specialize = [
                'typename '
                + self.parent.get_child("global").item2specialize(
                    name, return_class=True)
                + '::Type'
            ]
        else:
            specialize = [name]
        lines += self.generate_function(
            name, specialize=specialize, **kwargs)
        return lines

    def generate_header_item(self, name, members):
        lines = []
        if not self.parent.as_class:
            lines += super(
                CEnumGeneratorCollectionBase, self).generate_header_item(
                    name, members)
        if not self.specialize_in_source:
            lines += self.generate_specialization(name, members,
                                                  for_header=True)
        return lines

    def generate_item(self, name, members):
        lines = []
        if not self.parent.as_class:
            lines += super(
                CEnumGeneratorCollectionBase, self).generate_item(
                    name, members)
        if self.specialize_in_source:
            lines += self.generate_specialization(name, members)
        return lines

    def generate_iteration(self, collection_name, iter_name):
        return (
            f"for ({iter_name} = {collection_name}.begin(); "
            f"{iter_name} != {collection_name}.end(); {iter_name}++)"
        )

    def generate_iterator_dref(self, iter_name):
        raise NotImplementedError

    def generate_add(self, collection_name, var_name):
        raise NotImplementedError

    def generate_find(self, collection_name, key_name, iter_name="it"):
        raise NotImplementedError

    def generate_utilty_methods(self, completed_utils, **kwargs):
        lines = []
        completed_utils.setdefault(self.collection_type, [])
        for k in self.utility_functions:
            if k in completed_utils[self.collection_type]:
                continue
            ikws = dict(kwargs)
            if ((k in ['error_prefix', 'operator<<']
                 and any(k in v for v in completed_utils.values()))):
                if k == 'operator<<':
                    ikws['function_param'] = {'for_class': True}
                else:
                    continue
            lines += self.generate_additional_method(
                k, utility=True, **ikws)
            completed_utils[self.collection_type].append(k)
        return lines

    def generate_additional_methods(self, **kwargs):
        lines = []
        for k in self.additional_functions:
            lines += self.generate_additional_method(k, **kwargs)
        return lines

    def generate_additional_method(self, function_type, enum_name='Type',
                                   enum_is_class=None, result=None,
                                   no_return=False, utility=False,
                                   function_param=None):
        lines = []
        if function_param is None:
            function_param = {}
        if enum_is_class is None:
            enum_is_class = self.parent.as_class
        if result is None:
            result = self.collection_name
        utility_suffix = '_' + self.collection_type.split('::')[-1]
        if enum_is_class:
            if utility:
                function_suffix = utility_suffix
            else:
                function_suffix = self.collection_name.title()
                if function_type in ['get', 'getdefault']:
                    function_suffix = function_suffix.rstrip('s')
                    function_suffix = function_suffix.replace('s_C3', '_C3')
        else:
            function_suffix = f"_enum_{self.function_suffix}"
        collection_type = self.generate_collection_type(enum_name)
        if function_type in ['error_prefix'] or function_type.startswith(
                'operator'):
            function_name = function_type
        elif function_type in ['getdefault']:
            function_name = (
                f"{function_type.rsplit('default', 1)[0]}"
                f"{function_suffix}"
            )
        else:
            function_name = f"{function_type}{function_suffix}"
        if function_type == 'is':
            return_type = 'bool'
        elif function_type in ['get', 'getdefault']:
            return_type = self.value_type
        elif function_type in ['print', 'operator<<']:
            return_type = 'std::ostream&'
        elif function_type in ['string', 'error_prefix']:
            return_type = 'std::string'
        else:
            return_type = 'void'
        args = []
        arg_names = []
        if utility and function_type not in ['error_prefix',
                                             'operator<<']:
            args.append(f'const {collection_type}& collection')
            arg_names.append('collection')
        if function_type in ['add', 'remove', 'is', 'get', 'getdefault',
                             'check', 'checkNot']:
            args.append(f'const {enum_name}& x')
            arg_names.append('x')
            if function_type == 'add' and hasattr(self, 'value_type'):
                args.append(f'const {self.value_type}& y')
                arg_names.append('y')
            elif function_type in ['check', 'checkNot']:
                args.append('const std::string& context = ""')
                arg_names.append('context')
            elif function_type == 'getdefault':
                args.append(f'const {self.value_type}& defaultV')
                arg_names.append('defaultV')
        elif function_type in ['addMultiple', 'removeMultiple']:
            args.append(f'const {collection_type}& x')
            arg_names.append('x')
        elif function_type == 'print':
            args += ['std::ostream& out', 'const unsigned int tab = 0']
            arg_names += ['out', 'tab']
        elif function_type == 'operator<<':
            args += ['std::ostream& out']
            arg_names += ['out', 'x']
            if function_param.get('for_class', False):
                args += [f'const {collection_type}& x']
            else:
                args += [f'const {enum_name}& x']
        elif function_type == 'string':
            args += ['const unsigned int tab = 0']
            arg_names += ['tab']
        docs = []
        body = []
        if not enum_is_class:
            const = '' if self.is_editable else 'const '
            body += [
                f"{const}{collection_type} {result} = "
                f"get{function_suffix};"
            ]
        if function_type not in self.additional_functions:
            raise NotImplementedError(
                f"Invalid function_type \'{function_type}\' "
                f"(valid values = {self.additional_functions})")
        if (not utility) and function_type in self.utility_functions:
            if function_type == 'error_prefix' or function_type.startswith(
                    'operator'):
                return []
            elif function_type == 'print':
                docs += [
                    f'Print the contents of {self.collection_name}',
                    '\\param[in,out] out Stream to print to',
                    '\\param[in] tab Indentation to add to each line',
                    '\\return Updated stream',
                ]
            elif function_type == 'string':
                docs += [
                    f'Serialize the contents of {self.collection_name}',
                    '\\param[in] tab Indentation to add to each line',
                    '\\return Serialized collection',
                ]
            body += [
                f"return {function_type}{utility_suffix}("
                f"{result}, {', '.join(arg_names)});"
            ]
        elif function_type == 'is':
            docs += [
                f'Check if a key is in {self.collection_name}',
                '\\param[in] x Key to check',
                '\\return true if x is present, false otherwise',
            ]
            body += [f"typename {collection_type}::const_iterator it;"]
            body += self.generate_find(result, "x", "it")
            body += [f"return (it != {result}.end());"]
        elif function_type in ['check', 'checkNot']:
            codeNot = ''
            strNot = ''
            if function_type == 'check':
                codeNot = '!'
                strNot = 'not '
            docs += [
                f'Throw an error if a key is {strNot}in '
                f'{self.collection_name}',
                '\\param[in] x Key to check',
                '\\param[in] context String describing context that ',
                '  should be used in the error message',
            ]
            body += [
                f'if ({codeNot}is{function_suffix}(x)) {{',
                f'  throw std::runtime_error('
                f'error_prefix() + context + ": \'" + '
                f'names.find(x)->second'
                f' + "\' is {strNot}in {self.collection_name}");',
                '}',
            ]
        elif function_type == 'clear':
            assert self.is_editable
            docs += [
                f'Remove all entries from {self.collection_name}'
            ]
            body += [f"{result}.clear();"]
            body += ['state_updated = true;']
        elif function_type in ['get', 'getdefault']:
            assert hasattr(self, 'value_type')
            body += [f"typename {collection_type}::const_iterator it;"]
            body += self.generate_find(result, "x", "it")
            dref = self.generate_iterator_dref("it")[1]
            docs += [
                f'Get the {function_suffix.lower()} value corresponding '
                f'to an enum key',
                '\\param[in] x Key to get value for',
            ]
            body += [
                f'if (it == {result}.end()) {{',
            ]
            if function_type == 'getdefault':
                docs += [
                    '\\param[in] defaultV Value to return if x is not '
                    'present'
                ]
                body += ['  return defaultV;',
                         '}']
            else:
                body += [
                    f'  throw std::runtime_error("Could not locate '
                    f'{function_suffix} for \'" + '
                    f'names.find(x)->second + "\'");',
                    '}'
                ]
            docs += [
                '\\return Value'
            ]
            body += [f"return {dref};"]
        elif function_type == 'error_prefix':
            docs += [
                'Get a prefix for errors describing the class',
                '\\return Prefix',
            ]
            body += [
                'std::string out;',
                'out += get_enum_names<PARAM_TYPE>().'
                'find(param_type)->second;',
                'out += "[";',
                'out += get_enum_names<MODULE>().find(module)->second;',
                'out += "]: ";',
                'return out;',
            ]
        elif function_type == 'operator<<':
            docs += [
                'Serialize an enum to an output stream',
                '\\param[in,out] out Output stream',
            ]
            if function_param.get('for_class', False):
                docs += [
                    '\\param[in] x Collection to serialize',
                ]
                body += [
                    f"print{function_suffix}(x, out);",
                    "return out;",
                ]
            else:
                docs += [
                    '\\param[in] x Key to serialize',
                ]
                body += [
                    'out << getName(x);',
                    'return out;'
                ]
            docs += [
                '\\return Updated stream',
            ]
        elif function_type == 'print':
            docs += [
                'Print the contents of a collection',
                '\\param[in] collection Object to print',
                '\\param[in,out] out Stream to print to',
                '\\param[in] tab Indentation to add to each line',
                '\\return Updated stream',
            ]
            body += ["const std::string space(tab * 4, ' ');"]
            itdref = self.generate_print(
                *self.generate_iterator_dref('it'),
                space='space', out='out')
            if self._print_prefix:
                body += [f"out << {self._print_prefix};"]
            body += [
                f"typename {collection_type}::const_iterator it;",
                f"{self.generate_iteration('collection', 'it')} {{",
                f"  {itdref}",
                "}",
            ]
            if self._print_suffix:
                body += [f"out << {self._print_suffix};"]
            body += [
                "return out;",
            ]
        elif function_type == 'string':
            docs += [
                'Serialize a collection to a string',
                '\\param[in] collection Object to serialize',
                '\\param[in] tab Indentation to add to each line',
                '\\return Serialized collection',
            ]
            body += [
                "std::ostringstream oss;",
                f"print{function_suffix}(collection, oss, tab);",
                "return oss.str();",
            ]
        elif function_type == 'remove':
            assert self.is_editable
            docs += [
                f'Remove an element from {self.collection_name}',
                '\\param[in] x Key to remove',
            ]
            body += [f"typename {collection_type}::iterator it;"]
            body += self.generate_find(result, "x", "it")
            body += [
                f"if (it != {result}.end()) {{",
                f"  {result}.erase(it);",
                "}",
            ]
            body += ['state_updated = true;']
        elif function_type == 'add':
            assert self.is_editable
            docs += [
                f'Add an element to {self.collection_name} if it is not '
                f'already present',
                '\\param[in] x Key to add',
            ]
            if hasattr(self, 'value_type'):
                docs += ['\\param y Value to add for x']
                body += self.generate_add(result, *arg_names)
            else:
                body += [
                    f"if (!is{function_suffix}(x)) {{",
                    f"  {self.generate_add(result, *arg_names)};",
                    "}"
                ]
            body += ['state_updated = true;']
        elif function_type.endswith('Multiple'):
            assert self.is_editable
            short = function_type.split('Multiple')[0]
            ftype = short + function_suffix
            itdref = ", ".join(self.generate_iterator_dref('it'))
            docs += [
                f'{short.title()} multiple elements to '
                f'{self.collection_name} if they are not already present',
                '\\param[in] x Elements to add',
            ]
            body += [
                f"typename {collection_type}::const_iterator it;",
                f"{self.generate_iteration('x', 'it')} {{",
                f"  {ftype}({itdref});",
                "}"
            ]
            body += ['state_updated = true;']
        else:
            raise NotImplementedError(
                f"Unimplemented function_type \'{function_type}\' "
                f"(valid values = {self.additional_functions})")
        if no_return:
            return body
        if docs:
            lines += ['/**']
            lines += ["  " + x for x in docs]
            lines += ['*/']
        static = 'static'
        if function_type in ['operator<<']:
            static = 'friend'
        lines += [f"{static} {return_type} {function_name}"
                  f"({', '.join(args)}) {{"]
        lines += ["  " + x for x in body]
        lines += ["}"]
        if function_type in ['operator<<'] and not function_param.get(
                'for_class', False):
            lines += self.generate_additional_method(
                function_type, enum_name=enum_name,
                enum_is_class=enum_is_class, result=result,
                no_return=no_return, utility=utility,
                function_param=dict(function_param, for_class=True))
        return lines

    def generate_function(self, name, for_header=False, result=None,
                          specialize_empty=False, enum_is_class=None,
                          specialize_direct=None, direct=False,
                          skip_items=[], function_type='get', **kwargs):
        lines = []
        kwargs.setdefault('spec_param', ['typename'])
        assert len(kwargs['spec_param']) == 1
        specialization, spec_var = self.specialization(lines, **kwargs)
        inline = 'inline ' if (specialization and for_header) else ''
        const = "" if self.is_editable else "const "
        key_type = (specialization.strip('<>') if specialization
                    else spec_var[0])
        class_type = None
        if enum_is_class is None:
            enum_is_class = self.parent.as_class
        if enum_is_class and specialization:
            class_type = self.parent.get_child('global').item2specialize(
                name, return_class=True)
            key_type = f'typename {class_type}::Type'
        collection_type = self.generate_collection_type(key_type)
        args = []
        arg_names = []
        if function_type in ['add', 'remove', 'is']:
            args.append(f'const {key_type}& x')
            arg_names.append('x')
            if function_type == 'add' and hasattr(self, 'value_type'):
                args.append(f'const {self.value_type}& y')
                arg_names.append('y')
        elif function_type in ['addMultiple', 'removeMultiple']:
            args.append(f'const {collection_type}& x')
        if enum_is_class and specialization:
            if result is None:
                if function_type == 'get':
                    result = f'{class_type}::{self.collection_name}'
                else:
                    result = (
                        f'{class_type}::{function_type}'
                        f'{self.collection_name.title()}('
                        f'{", ".join(arg_names)})'
                    )
        if function_type == 'is':
            return_type = 'bool'
            return_value = ' = false'
            return_ref = ''
        else:
            return_type = f"{const}{collection_type}"
            return_value = ''
            return_ref = '&'
        lines += [
            f'{inline}{return_type}{return_ref} {function_type}_enum_'
            f'{self.function_suffix}{specialization}('
            f'{", ".join(args)}) {{',
        ]
        if result is None:
            if specialization:
                if specialize_empty:
                    result = 'result'
                    lines += [
                        f'  static{return_type}result{return_value};'
                    ]
                else:
                    if not direct:
                        raise AssertionError(
                            "direct must be provide names of members "
                            "for non-empty specialization")
                    self.add_enum(name)
                    result = 'collection'
                    lines += [
                        '  ' + x for x in self.generate_definition(
                            name, direct, no_return=True,
                            var_name=result, skip_items=skip_items,
                            function_type=function_type,
                        )]
                    if function_type == 'is':
                        result = None
            else:
                result = 'result'
                lines += [
                    f'  static {return_type} result{return_value};',
                    f'  throw std::runtime_error(\"No enum '
                    f'{self.collection_name} collection could be found\");'
                ]
        if result is not None:
            lines += [f'  return {result};']
        lines += ['}']
        kwargs.update(for_header=for_header, skip_items=skip_items)
        kwargs.pop('specialize', None)
        if (not specialization) and specialize_empty:
            lines += self.generate_function(
                name,
                specialize=[specialize_empty],
                specialize_empty=specialize_empty,
                **kwargs
            )
        if (not specialization) and specialize_direct:
            for k, v in specialize_direct.items():
                lines += self.generate_function(
                    k,
                    specialize=[k],
                    direct=v,
                    enum_is_class=False,
                    **kwargs
                )
        return lines


class CEnumGeneratorMapBase(CEnumGeneratorCollectionBase):

    perfile_options = dict(
        CEnumGeneratorCollectionBase.perfile_options,
        value_type={
            'type': str,
            'help': "C++ type of values in the map",
        },
    )
    default_value_type = None
    collection_type = 'std::map'
    _additional_functions = (
        CEnumGeneratorCollectionBase._additional_functions + [
            'get', 'getdefault',
        ]
    )
    _print_prefix = "space << \"{\" << std::endl;"
    _print_suffix = "space << \"}\""

    def __init__(self, *args, **kwargs):
        kwargs.setdefault("value_type", self.default_value_type)
        super(CEnumGeneratorMapBase, self).__init__(*args, **kwargs)

    @property
    def add_value_args(self):
        return [(f"const {self.value_type}&", "value")]

    def generate_docs(self, name):
        name_doc = self.collection_name.title()
        return f'{name_doc} for values'

    def generate_collection_param(self, *args, **kwargs):
        out = super(CEnumGeneratorMapBase, self).generate_collection_param(
            *args, **kwargs)
        out.append(self.value_type)
        return out

    def generate_value(self, x):
        out = super(CEnumGeneratorMapBase, self).generate_value(x)
        if out and self.value_type == 'std::string':
            out = f"\"{out}\""
        return out

    def generate_member(self, x, width=None, width_value=None,
                        enum_prefix='', member_suffix=''):
        assert width is not None and width_value is not None
        value = self.generate_value(x)
        if not value:
            return []
        pad = (width_value - len(value)) * ' '
        return [
            f"  {{{(enum_prefix + x['name']):{width}}, {value}{pad}}},"
            f"{member_suffix}"]

    def generate_definition(self, name, members, **kwargs):
        width_value = self.max_width(members, func=self.generate_value)
        lines = super(CEnumGeneratorMapBase, self).generate_definition(
            name, members, width_value=width_value, **kwargs)
        return lines

    def generate_iterator_dref(self, iter_name):
        return [f"{iter_name}->first", f"{iter_name}->second"]

    def generate_add(self, collection_name, key_name, val_name):
        return f"{collection_name}.emplace({key_name}, {val_name})"

    def generate_find(self, collection_name, key_name, iter_name="it"):
        return [f"{iter_name} = {collection_name}.find({key_name});"]

    def generate_print(self, *args, space=None, out='std::cout'):
        if space:
            space = f" << {space}"
        else:
            space = ''
        assert len(args) == 2
        key = f"names.find({args[0]})->second"
        val = f"{args[1]}"
        return (f'{out}{space} << "  " << {key} << " = " << {val} '
                f'<< std::endl;')


class CEnumGeneratorVectorBase(CEnumGeneratorCollectionBase):

    collection_type = 'std::vector'
    _additional_functions = (
        CEnumGeneratorCollectionBase._additional_functions + [
            'is', 'check', 'checkNot',
        ]
    )
    _print_prefix = "space << \"[\""
    _print_suffix = "\"]\""  # " << std::endl;"

    def generate_docs(self, name):
        name_doc = self.collection_name.rstrip('s')
        name_doc = name_doc.replace('s_C3', '_C3')
        return f'Values that are {name_doc}'

    def generate_member(self, x, width=None, enum_prefix=''):
        if not self.generate_value(x):
            return []
        assert width
        return [f"  {(enum_prefix + x['name']):{width}},"]

    def generate_iterator_dref(self, iter_name):
        return [f"(*({iter_name}))"]

    def generate_add(self, collection_name, var_name):
        return f'{collection_name}.push_back({var_name})'

    def generate_find(self, collection_name, key_name, iter_name="it"):
        dref = self.generate_iterator_dref(iter_name)[0]
        return [
            self.generate_iteration(collection_name, iter_name) + "{",
            f"  if ({dref} == {key_name}) break;",
            "}",
        ]

    def generate_print(self, *args, space=None, out='std::cout'):
        assert len(args) == 1
        key = f"names.find({args[0]})->second"
        return f'{out} << {key} << ",";'


class CEnumGeneratorGlobalHeader(CEnumGeneratorBase):

    name = 'global'
    file_suffix = ''
    prefix = CEnumGeneratorBase.prefix + [
        '#include <string>',
        '#include <map>',
        '#include <vector>',
        '#include <iostream>',
        '#include <fstream>',
        '#include <sstream>',
        '#ifdef _MSC_VER',
        '// There is a bug in the MSVC compiler where it does not allow',
        '//   declaration of a specialized class member enum',
        '//   https://developercommunity.visualstudio.com/t/'
        'Explicit-specialization-of-member-enumer/10609934',
        '#define EPHOTO_USE_SCOPED_ENUM 1',
        '#endif // _MSC_VER',
        '#ifdef EPHOTO_USE_SCOPED_ENUM',
        '#define SCOPED_ENUM_TYPE(name) name::',
        '#else // EPHOTO_USE_SCOPED_ENUM',
        '#define SCOPED_ENUM_TYPE(name)',
        '#endif // EPHOTO_USE_SCOPED_ENUM',
    ]
    explicit_dst = True
    perfile_options = dict(
        {k: v for k, v in CEnumGeneratorBase.perfile_options.items()
         if k not in ['define_in_header']},
        enum_name={
            'type': str,
            'help': "Name that should be used for the global enum",
        },
        accum_enum_name={
            'type': str,
            'help': ("Name that should be used for enum accumulated "
                     "between calls"),
            'default': "PARAM_TYPE",
        },
        empty_enum_name={
            'type': str,
            'help': "Name that should be used for empty enum",
            'default': "EMPTY_ENUM",
        },
        strip_suffix={
            'type': str,
            'help': ("Suffix that should be stripped from global enum "
                     "members"),
        },
    )

    def __init__(self, *args, **kwargs):
        kwargs.setdefault('enum_name', self.name.upper())
        kwargs.setdefault('prefixes', {})
        super(CEnumGeneratorGlobalHeader, self).__init__(*args, **kwargs)
        assert self.parent

    def generate_item(self, name, members, width=None):
        assert width
        key = self.add_member(name, return_name=True,
                              replace_with_prefix=True,
                              add_prefix=f'{self.enum_name}_',
                              strip_suffix=self.strip_suffix)
        return [f"{key:{width}},"]

    def generate_type_struct(self, name, result=None, for_header=False,
                             **kwargs):
        lines = []
        func_name = f'{name}2Enum'
        if self.parent.as_class:
            lines += [
                f'#define {func_name} {self.parent.as_class}'
            ]
            return lines
        assert not self.parent.as_class
        kwargs.setdefault('spec_param', self.spec_param)
        specialization, spec_var = self.specialization(lines, **kwargs)
        lines += [
            f'struct {func_name}{specialization} {{',
            'public:',
        ]
        if result is None and (not specialization):
            result = self.empty_enum_name
        assert result is not None
        lines += [
            f'  typedef enum {result} Type;',
            '};',
        ]
        return lines

    def generate_param_function(self, dst, result=None, for_header=False,
                                **kwargs):
        lines = []
        func_name = f'get_enum_{dst.lower()}'
        kwargs.setdefault('spec_param', ['typename'])
        specialization, spec_var = self.specialization(lines, **kwargs)
        inline = 'inline ' if (specialization and for_header) else ''
        lines += [
            f'{inline}{dst} {func_name}{specialization}() {{',
        ]
        if (not specialization) and (not self.parent.as_class):
            lines += [
                f'  throw std::runtime_error(\"No {dst.lower()} '
                f'could be found\");',
            ]
        if result is None and (not specialization):
            if self.parent.as_class:
                result = f'{spec_var[0]}::{dst}'
            else:
                result = f'{dst}_NONE'
        assert result is not None
        lines += [
            f'  return {result};',
            '}',
        ]
        if (not specialization) and (not self.parent.as_class):
            kwargs.update(
                result=result,
                for_header=for_header,
                specialize=[self.empty_enum_name],
            )
            lines += self.generate_param_function(dst, **kwargs)
        return lines

    @property
    def spec_param(self):
        out = [self.enum_name]
        if self.accum_enum_name:
            out.append(self.accum_enum_name)
        return out

    @property
    def spec_var(self):
        # TODO: Add command line option for these names
        out = ['M']
        if self.accum_enum_name:
            out.append('PT')
        return out

    def item2specialize(self, name, return_class=False):
        out = [f"{self.enum_name}_{name.rsplit(self.strip_suffix)[0]}"]
        if self.accum_enum_name:
            out.append(f"{self.accum_enum_name}{self.strip_suffix}")
        if return_class:
            assert self.parent.as_class
            out = f"{self.parent.as_class}<{', '.join(out)}>"
        return out

    def generate(self, indent='', **kwargs):
        lines = []
        includes = {'global': []}
        for k in self.parent.added_collections:
            includes[k] = []
        existing_enum = []
        existing_accum_enum = []
        if os.path.isfile(self.dst):
            with open(self.dst, 'r') as fd:
                existing = fd.read().splitlines()
            for x in existing:
                if x.strip().startswith('#include'):
                    for k in self.parent.added_collections:
                        base = os.path.basename(
                            self.parent.get_child(k).get_child(
                                'header').dst)
                        if x.endswith(f'{base.split("_")[-1]}"'):
                            if k in self.parent.added_files:
                                includes[k].append(x.strip())
                            break
                    else:
                        if x.strip().endswith(".hpp\""):
                            includes['global'].append(x.strip())
                elif x.strip().startswith(f'{self.enum_name}_'):
                    new_val = x.split(
                        f'{self.enum_name}_')[-1].split(',')[0].strip()
                    if new_val not in ['NONE', 'MAX']:
                        existing_enum.append(new_val)
                elif (self.accum_enum_name
                      and x.strip().startswith(f'{self.accum_enum_name}_')):
                    new_val = x.split(
                        f'{self.accum_enum_name}_')[-1].split(',')[0].strip()
                    if new_val not in ['NONE', 'MAX']:
                        existing_accum_enum.append(new_val)
        include = self.parent.include_self(
            self.dst, rootdir=self.root_include_dir)
        for x in include:
            if x not in includes['global']:
                includes['global'].append(x)
        for k in self.src.param.keys():
            key = self.add_member(k, replace_with_prefix=True,
                                  return_name=True,
                                  strip_suffix=self.strip_suffix,
                                  add_enum=self.enum_name)
            if key not in existing_enum:
                existing_enum.append(key)
        enum_members = [
            self.add_member(x, add_prefix=f'{self.enum_name}_',
                            add_enum=self.enum_name)
            for x in ['NONE'] + existing_enum + ['MAX']
        ]
        lines += self.parent.generate_enum(
            self.enum_name, enum_members, as_class=False,
        )
        # Param types
        if self.accum_enum_name:
            new_accum_enum = self.strip_suffix.strip('_')
            if new_accum_enum not in existing_accum_enum:
                existing_accum_enum.append(new_accum_enum)
            accum_enum_members = [
                self.add_member(x, add_prefix=f'{self.accum_enum_name}_',
                                add_enum=self.accum_enum_name)
                for x in ['NONE'] + existing_accum_enum + ['MAX']
            ]
            lines += self.parent.generate_enum(
                self.accum_enum_name, accum_enum_members, as_class=False,
            )
        # Utility for getting module id from enum type
        lines += [
            f'// Utility for getting {self.enum_name.lower()} '
            f'id from enum type',
        ]
        lines += self.generate_param_function(
            self.enum_name, for_header=True)
        lines += ['']
        # Utility for getting param type from enum type
        if self.accum_enum_name:
            lines += [
                f'// Utility for getting {self.accum_enum_name.lower()} '
                f'from enum type',
            ]
            lines += self.generate_param_function(
                self.accum_enum_name, for_header=True)
            lines += ['']
        # Utilities for getting names/values from enum type
        for k in self.parent.added_collections:
            lines += [
                f'// Utility for getting {k} from enum',
            ]
            specialize_direct = None
            if k == 'names':
                specialize_direct = {}
                specialize_direct[self.enum_name] = enum_members
                if self.accum_enum_name:
                    specialize_direct[self.accum_enum_name] = (
                        accum_enum_members)
            lines += self.parent.get_child(k).generate_function(
                self.enum_name, spec_param=['typename'],
                specialize_direct=specialize_direct,
                for_header=True, skip_items=['NONE', 'MAX'])
        # Base class
        if self.parent.as_class:
            lines += ['// Unspecialized enum']
            lines += self.parent.generate_enum(
                self.parent.as_class, [],
                spec_param=self.spec_param, spec_var=self.spec_var,
                specialize=False)
        else:
            # Empty enum
            lines += ['// Empty enum']
            lines += self.parent.generate_enum(
                self.empty_enum_name, [],
                spec_param=self.spec_param, spec_var=self.spec_var,
                specialize=False)
        # Include for module/param specific enums
        added_include = False
        for k in includes['global']:
            if k and k not in lines:
                added_include = True
                lines.append(k)
        if added_include:
            lines += ['']
        # Utilities for getting names/values from enum type
        for k in self.parent.added_collections:
            if k in self.parent.added_files:
                new_include = self.parent.get_child(
                    k).get_child('header').include_self(
                        self.dst, rootdir=self.root_include_dir)
                for x in new_include:
                    if x not in includes[k]:
                        includes[k].append(x)
            if includes[k]:
                lines += [f'// Specializations for get_enum_{k}']
                lines += includes[k]
        lines += ['']
        lines += [
            f'// Utility for getting enum type from '
            f'{self.enum_name.lower()} & '
            f'{self.accum_enum_name.lower()}',
        ]
        lines += self.generate_type_struct(
            self.enum_name, for_header=True)
        lines += [self.comment + ' ' + x for x in self.preserve_marker]
        if not self.parent.as_class:
            # Begin preserved lines
            for k, v in self.src.param.items():
                key = k.rsplit(self.strip_suffix)[0]
                lines += self.generate_type_struct(
                    self.enum_name, result=k, for_header=True,
                    specialize=[f'{self.enum_name}_{key}',
                                f'{self.accum_enum_name}'
                                f'{self.strip_suffix}'])
                lines += ['']
        if self.namespaces:
            lines = [
                ('  ' * i) + f'namespace {x} {{'
                for i, x in enumerate(self.namespaces)
            ] + [
                ('  ' * len(self.namespaces)) + x for x in lines
            ] + [
                ('  ' * (len(self.namespaces) - (i + 1))) + '}'
                for i in range(len(self.namespaces))
            ]
        return lines


class CEnumGeneratorHeader(CEnumGeneratorBaseHeader):

    name = 'c'
    file_suffix = '_enum'
    perfile_options = dict(
        CEnumGeneratorBaseHeader.perfile_options,
        as_class={
            'type': str,
            'help': "Create enum as a class with this name",
        },
        enum_in_source={
            'action': 'store_true',
            'help': "Define the enum in the source code."
        },
        macro_suffix={
            'type': str,
            'help': "Suffix to use for members macro",
        },
        explicit_values={
            'action': 'store_true',
            'help': "Explicitly define the value for each enum member",
        },
    )
    added_file_classes = {
        'global': CEnumGeneratorGlobalHeader,
    }
    added_collection_classes = {
        'map': {
            'names': {
                'default_value_type': 'std::string',
                'default_value_key': 'abbr',
                '_utility_functions': [
                    x for x in CEnumGeneratorMapBase._utility_functions
                    if x not in ['print', 'string']
                ],
            },
            'values': {
                'default_value_type': 'double',
                'default_value_key': 'val',
            },
            'alternate_values': {
                'default_value_type': 'double',
                'default_value_key': 'val_alt',
                'default_secondary_value_key': 'val',
            },
            'glymaids': {
                'default_value_type': 'std::string',
                'default_value_key': 'GLYMAID',
            },
        },
        'vector': {
            'constant': {
                'default_value_key': 'CONST',
            },
            'calculated': {
                'default_value_key': 'CALC',
            },
            'nonvector': {
                'default_value_key': 'NON_VECTOR',
            },
            'skipped': {
                'default_value_key': 'SKIPPED',
                'default_is_editable': True,
            },
            'resetone': {
                'default_value_key': 'RESET_ONE',
            },
            'initonce': {
                'default_value_key': 'INIT_ONCE',
            },
        },
    }

    @staticmethod
    def create_child_classes(cls):
        CEnumGeneratorBaseHeader.create_child_classes(cls)
        if cls.name is None or not cls.is_parent:
            return
        added = {}
        for ktype, classes in cls.added_collection_classes.items():
            if ktype == 'map':
                base = CEnumGeneratorMapBase
            elif ktype == 'vector':
                base = CEnumGeneratorVectorBase
            else:
                raise NotImplementedError(
                    f"Unsupported collection class: {ktype}")
            for k, v in classes.items():
                added[k] = base.create_class(k, **v)
        cls.added_file_classes = dict(cls.added_file_classes, **added)

    @property
    def added_maps(self):
        return [k for k, v in self.added_file_classes.items()
                if issubclass(v, CEnumGeneratorMapBase)]

    @property
    def added_vectors(self):
        return [k for k, v in self.added_file_classes.items()
                if issubclass(v, CEnumGeneratorVectorBase)]

    @property
    def added_collections(self):
        return self.added_maps + self.added_vectors

    def generate_member(self, x, width=None, width_val=None,
                        name_only=False, explicit_values=False):
        assert width is not None and width_val is not None
        val = ''
        docs = ''
        if not name_only:
            if ((x.get('explicit_idx', False)
                 or self.explicit_values or explicit_values)):
                val = f" = {x['idx']}"
            if x.get('doc', False):
                docs = f"  //!< {x['doc']}"
        return [f"  {x['name']:{width}}{val:{width_val}},{docs}"]

    def generate_enum_class_helper(self, name, members, specialization='',
                                   template_lines=[], enum_type='int',
                                   as_class=False):
        enum_name_ext = f'ENUM_{name}' if specialization else enum_type
        lines = []
        if specialization:
            lines += self.generate_definition_enum(
                name, members, enum_name=enum_name_ext,
                enum_type=enum_type, as_class=as_class,
                scoped_enum=True)
        lines += template_lines
        lines += [
            f'struct enum_helper{specialization} {{',
            f'  typedef {enum_name_ext} type;',
            '};'
        ]
        return lines

    def generate_declaration(self, name, members, enum_name=None,
                             enum_type='int', members_only=False,
                             as_class=None, **kwargs):
        if as_class is None:
            as_class = self.as_class
        if not as_class:
            return self.generate_definition_enum(
                name, members, enum_name=enum_name, enum_type=enum_type,
                as_class=as_class)  # , **kwargs)
        if enum_name is None:
            enum_name = 'Type'
        lines = []
        template_lines = []
        class_name = as_class
        kwargs.setdefault('spec_param',
                          self.get_child('global').spec_param)
        kwargs.setdefault('spec_var',
                          self.get_child('global').spec_var)
        specialization, spec_var = self.specialization(
            template_lines, **kwargs)
        if specialization:
            members_only = True
        template = 'template<> ' if specialization else ''
        static = 'static ' if not specialization else ''
        enum_prefix = (
            f'{class_name}{specialization}::' if specialization else '')
        enum_name_full = f'{enum_prefix}{enum_name}'
        if specialization:
            enum_name_full = f'typename {enum_name_full}'
        if members_only:
            if specialization and not self.enum_in_source:
                lines += ['#ifdef EPHOTO_USE_SCOPED_ENUM']
                lines += self.generate_enum_class_helper(
                    name, members, specialization=specialization,
                    template_lines=template_lines, enum_type=enum_type,
                    as_class=as_class)
                lines += ['#else // EPHOTO_USE_SCOPED_ENUM']
                lines += template_lines
                lines += self.generate_definition_enum(
                    name, members, enum_name=enum_name,
                    enum_type=enum_type, enum_prefix=enum_prefix,
                    as_class=as_class)
                lines += ['#endif // EPHOTO_USE_SCOPED_ENUM']
            else:
                if as_class and spec_var:
                    lines += [
                        '#ifdef EPHOTO_USE_SCOPED_ENUM',
                        f'typedef typename '
                        f'enum_helper<{", ".join(spec_var)}>::'
                        f'type {enum_name};',
                        '#else // EPHOTO_USE_SCOPED_ENUM',
                    ]
                member_prefix = 'enum '
                lines += [
                    f'{template}{member_prefix}{enum_prefix}{enum_name} : '
                    f'{enum_type};',
                ]
                if as_class and spec_var:
                    lines += [
                        '#endif // EPHOTO_USE_SCOPED_ENUM',
                    ]
            if spec_var and not specialization:
                for p, t in zip(kwargs['spec_param'], spec_var):
                    lines += [f'{static}const {p} {p.lower()};']
            if specialization:
                lines += self.generate_definition_macro(
                    name, members, enum_name=enum_name,
                    enum_prefix=enum_prefix)
                lines += ['#ifndef _MSC_VER']
            lines += [
                f'{template}{static}const std::vector<'
                f'{enum_name_full}> {enum_prefix}all;'
            ]
            if not specialization:
                lines[-1] += '  /**< All enum values */'
            lines += [
                f'{template}{static}bool {enum_prefix}state_updated;'
            ]
            if not specialization:
                lines[-1] += (
                    '  /** One of the editable collection(s) was '
                    'updated */'
                )
            for k in self.added_collections:
                self.get_child(k).add_enum(enum_name)
                collection_type = self.get_child(k).generate_collection_type(
                    enum_name_full)
                const = '' if self.get_child(k).is_editable else 'const '
                lines += [
                    f'{template}{static}{const}{collection_type} '
                    f'{enum_prefix}{self.get_child(k).collection_name};'
                ]
                docs = self.get_child(k).generate_docs(k)
                if docs and not specialization:
                    lines[-1] += f'  /**< {docs} */'
            if not specialization:
                completed_utils = {}
                for k in self.added_collections:
                    lines += self.get_child(k).generate_utilty_methods(
                        completed_utils,
                        enum_name=enum_name_full, enum_is_class=as_class)
                    lines += self.get_child(k).generate_additional_methods(
                        enum_name=enum_name_full, enum_is_class=as_class)
            if specialization:
                lines += [
                    '#endif // _MSC_VER',
                    ''
                ]
            return lines
        if spec_var and not specialization:
            lines += ['#ifdef EPHOTO_USE_SCOPED_ENUM']
            lines += self.generate_enum_class_helper(
                name, members, specialization=specialization,
                template_lines=template_lines, enum_type=enum_type,
                as_class=as_class)
            lines += ['#endif // EPHOTO_USE_SCOPED_ENUM']
        lines += template_lines
        lines += [
            f'class {class_name}{specialization} {{',
            'public:',
        ]
        lines += [
            '  ' + x for x in self.generate_declaration(
                name, members, enum_name=enum_name, enum_type=enum_type,
                members_only=True, **kwargs)
        ]
        lines += ["};"]
        # Definition of static members for unspecialized class
        if spec_var and not specialization:
            enum_prefix = f'{class_name}<{", ".join(spec_var)}>::'
            enum_name_full = f'typename {enum_prefix}{enum_name}'
            for p, t in zip(kwargs['spec_param'], spec_var):
                lines += template_lines
                lines += [
                    f'const {p} {enum_prefix}{p.lower()} = {t};'
                ]
            # lines += template_lines
            # lines += [f'bool {enum_prefix}state_updated = true;']
            for k in self.added_collections:
                self.get_child(k).add_enum(enum_name)
                collection_type = self.get_child(k).generate_collection_type(
                    enum_name_full)
                const = '' if self.get_child(k).is_editable else 'const '
                lines += template_lines
                lines += [
                    f'{const}{collection_type} '
                    f'{enum_prefix}{self.get_child(k).collection_name}'
                    f' = {{}};'
                ]
        return lines

    def generate_definition_enum(self, name, members, enum_name=None,
                                 enum_type='int', as_class=None,
                                 enum_prefix='', scoped_enum=False):
        lines = []
        if as_class is None:
            as_class = self.as_class
        if enum_name is None:
            if as_class:
                enum_name = 'Type'
            else:
                enum_name = name
        width = self.max_width(members)
        width_val = self.max_width(members, key='idx')
        if as_class and scoped_enum:
            member_prefix = 'enum class '
        else:
            member_prefix = 'enum '
        lines += [f'{member_prefix}{enum_prefix}{enum_name} : {enum_type} {{']
        lines += [
            '  ' + x for x in
            super(CEnumGeneratorBaseHeader, self).generate_item(
                name, members, width=width, width_val=width_val)
        ]
        lines += ['};']
        return lines

    def generate_definition_macro(self, name, members, enum_name=None,
                                  enum_prefix=''):
        macro_name = name
        if self.macro_suffix is not None:
            macro_name = name.rsplit('_', 1)[0] + self.macro_suffix
        lines = [
            f'#define MEMBERS_{macro_name}'
        ]
        # members = [x for x in members
        #            if not x['name'].endswith(('NONE', 'MAX'))]
        if members:
            lines[-1] += '\t\t\\'
        width = self.max_width(members)
        width_val = self.max_width(members, key='idx')
        values = super(CEnumGeneratorBaseHeader, self).generate_item(
            name, members, width=width, width_val=width_val,
            name_only=True)
        for i in range(len(values)):
            if i == len(values) - 1:
                values[i] = '  ' + values[i].rstrip(',').rstrip()
            else:
                values[i] = '  ' + values[i] + '\t\t\\'
        lines += values
        return lines

    def generate_definition(self, name, members, enum_name=None,
                            enum_type='int', as_class=None, **kwargs):
        if as_class is None:
            as_class = self.as_class
        if enum_name is None:
            if as_class:
                enum_name = 'Type'
            else:
                enum_name = name
        first = "NONE"
        last = "MAX"
        skip_items = [first, last]
        if (not members) or members[0]['abbr'] != first:
            members.insert(0, {'name': first, 'abbr': first})
        if (not members) or members[-1]['abbr'] != last:
            members.append({'name': last, 'abbr': last})
        members_core = [
            x for x in members if x['abbr'] not in skip_items
        ]
        lines = []
        template_lines = []
        enum_prefix = ''
        specialization = ''
        if as_class:
            class_name = as_class
            kwargs.setdefault('spec_param',
                              self.get_child('global').spec_param)
            kwargs.setdefault('spec_var',
                              self.get_child('global').spec_var)
            kwargs.setdefault('specialize',
                              self.get_child('global').item2specialize(name))
            specialization, spec_var = self.specialization(
                template_lines, **kwargs)
            enum_prefix = f'{class_name}{specialization}::'
        enum_member_prefix = enum_prefix
        if as_class:
            enum_member_prefix += f'SCOPED_ENUM_TYPE({enum_name})'
        enum_name_full = f'{enum_prefix}{enum_name}'
        if specialization:
            enum_name_full = f'typename {enum_name_full}'
        if self.enum_in_source:
            lines += template_lines
            lines += self.generate_definition_enum(
                name, members, enum_name=enum_name, enum_type=enum_type,
                enum_prefix=enum_prefix, as_class=as_class)
        if as_class:
            prefixed_names = [
                enum_member_prefix + x["name"] for x in members_core
            ]
            template = 'template<> ' if specialization else ''
            lines += [
                f'{template}const '
                f'std::vector<{enum_name_full}> '
                f'{enum_prefix}all = '
                f'{{{", ".join(prefixed_names)}}};',
                f'{template}bool '
                f'{enum_prefix}state_updated = true;',
            ]
            for k in self.added_collections:
                self.get_child(k).add_enum(enum_name)
                if template:
                    lines += [template]
                lines += self.get_child(k).generate_definition(
                    enum_name, members,
                    var_name=(f'{enum_prefix}'
                              f'{self.get_child(k).collection_name}'),
                    skip_items=skip_items, in_class=enum_prefix)
        lines += ['']
        return lines

    def generate_source_item(self, name, members):
        if not self.as_class:
            return []
        specialize = self.get_child('global').item2specialize(name)
        return self.generate_definition(name, members,
                                        specialize=specialize)

    def generate_source_closing(self, **kwargs):
        lines = super(CEnumGeneratorHeader, self).generate_source_closing(
            **kwargs)
        for k in ['NONE', 'MAX']:
            members = [self.add_member(x) for x in ['NONE', 'MAX']]
            name = f"{k}{self.get_child('global').strip_suffix}"
            specialize = self.get_child('global').item2specialize(name)
            lines += self.generate_definition(name, members,
                                              specialize=specialize)
        return lines

    def generate_item(self, name, members, as_class=None, **kwargs):
        if as_class is None:
            as_class = self.as_class
        if as_class:
            kwargs.setdefault('spec_param',
                              self.get_child('global').spec_param)
            kwargs.setdefault('spec_var',
                              self.get_child('global').spec_var)
            kwargs.setdefault('specialize',
                              self.get_child('global').item2specialize(name))
        lines = self.generate_declaration(
            name, members, as_class=as_class, **kwargs)
        if as_class and kwargs['specialize']:
            specialization, spec_var = self.specialization(None, **kwargs)
            class_name = as_class
            indent = ''
            contexts = [
                k.rsplit(k0, 1)[-1].strip('_') for k0, k in
                zip(kwargs['spec_param'], kwargs['specialize'])
            ]
            contexts = contexts[::-1]
            for kn in contexts[:-1]:
                lines += [f'{indent}namespace {kn} {{']
                indent += '  '
            lines += [
                f'{indent}typedef {class_name}{specialization} '
                f'{contexts[-1]};'
            ]
            for _ in contexts[:-1]:
                indent = indent[:-2]
                lines += [f'{indent}}}']
        lines += ['']
        return lines

    def generate(self, *args, **kwargs):
        lines = super(CEnumGeneratorHeader, self).generate(*args, **kwargs)
        for k in ['NONE', 'MAX']:
            members = [self.add_member(x) for x in ['NONE', 'MAX']]
            lines += self.generate_enum(
                f"{k}{self.get_child('global').strip_suffix}", members)
        return lines


class FortranEnumGeneratorCHeader(EnumGeneratorBase):

    name = 'fortran_wrapper_header'
    file_prefix = 'c_wrapper_'
    file_extension = '.h'
    types_cxx = {}

    def generate_member(self, x, tname=None):
        return [f"  FYGG_API extern const {tname} {x['name']}_F;"]

    def generate_item(self, name, members):
        lines = []
        tname = self.types_cxx.get(name, 'int')
        if tname == 'int':
            return lines
        lines.append('')
        lines += super(FortranEnumGeneratorCHeader, self).generate_item(
            name, members, tname=tname)
        lines.append('')
        return lines

    def generate(self, indent='', **kwargs):
        lines = [
            f'#ifndef {self.basename}_WRAPPER_H_',
            f'#define {self.basename}_WRAPPER_H_',
            '',
            '#ifdef __cplusplus',
            '#include <cstdint>',
            'extern "C" {',
            '#else',
            '#include "stdint.h"',
            '#endif',
        ]
        lines += super(FortranEnumGeneratorCHeader, self).generate(
            indent=indent, **kwargs)
        lines += [
            '',
            '#ifdef __cplusplus',
            '}',
            '#endif',
            '',
            f'#endif // {self.basename}_WRAPPER_H_',
        ]
        return lines


class FortranEnumGeneratorCSource(CMixin, EnumGeneratorBase):

    name = 'fortran_wrapper'
    file_prefix = 'c_wrapper_'
    file_extension = '.c'
    added_file_classes = {
        'header': FortranEnumGeneratorCHeader
    }

    @property
    def types_cxx(self):
        return self.added_files['header'].types_cxx

    @property
    def skip_items(self):
        return self.added_files['header'].skip_items

    def generate_member(self, x, tname=None):
        assert tname
        return [f"  const {tname} {x['name']}_F = {x['name']};"]

    def generate_item(self, name, members):
        lines = []
        tname = self.types_cxx.get(name, 'int')
        if tname == 'int':
            return lines
        lines.append('')
        lines += super(FortranEnumGeneratorCSource, self).generate_item(
            name, members, tname=tname)
        lines.append('')
        return lines

    def generate(self, indent='', **kwargs):
        lines = self.include_header()
        lines += self.src.include_header(caller=self.dst)
        lines += [
            '#ifdef __cplusplus',
            'extern "C" {',
            '#endif',
            ''
        ]
        lines += super(FortranEnumGeneratorCSource, self).generate(
            indent=indent, **kwargs)
        lines += [
            '',
            '#ifdef __cplusplus',
            '}',
            '#endif',
        ]
        return lines


# Version that binds to constants from C
class FortranEnumGeneratorBind(EnumGeneratorBase):

    name = 'fortran_bind'
    file_extension = '.F90'
    added_file_classes = {
        'c_wrapper': FortranEnumGeneratorCSource
    }
    prefix = [
        '#ifndef DOXYGEN_SHOULD_SKIP_THIS',
    ]
    suffix = [
        '#endif',
    ]

    @property
    def types_cxx(self):
        return self.added_files['c_wrapper'].types_cxx

    def generate_member(self, x, tname=None):
        assert tname
        if tname == 'int':
            return [f"        {x['name']} = {x['idx']}, &"]
        else:
            return [
                f"integer(kind=c_{tname}), protected, "
                f"bind(c, name=\"{x['name']}_F\") :: {x['name']}"]

    def generate_item(self, name, members):
        lines = ['']
        tname = self.types_cxx.get(name, 'int')
        if tname == 'int':
            lines += [
                'enum, bind( C )',
                '   enumerator :: &',
            ]
        lines += super(FortranEnumGeneratorBind, self).generate_item(
            name, members, tname=tname)
        if tname == 'int':
            lines[-1] = lines[-1].split(',')[0]
            lines += [
                'end enum',
            ]
        lines += ['']
        return lines


# Version that just sets the values directly
class FortranEnumGeneratorValue(EnumGeneratorBase):

    name = 'fortran_value'
    file_extension = '.F90'
    added_file_classes = {
        'c_wrapper': FortranEnumGeneratorCSource
    }
    prefix = [
        '#ifndef DOXYGEN_SHOULD_SKIP_THIS',
    ]
    suffix = [
        '#endif',
    ]

    @property
    def types_cxx(self):
        return self.added_files['c_wrapper'].types_cxx

    def generate_member(self, x, tname=None, tsuffix=None):
        assert tname
        if tname == 'int':
            return [f"        {x['name']} = {x['idx']}, &"]
        else:
            assert tsuffix
            return [
                f"integer(kind={tsuffix}), parameter :: "
                f"{x['name']} = {x['idx']}_{tsuffix}"]

    def generate_item(self, name, members):
        lines = ['']
        tname = self.types_cxx.get(name, 'int')
        tsuffix = None
        if tname == 'int':
            lines += [
                '  enum, bind( C )',
                '     enumerator :: &',
            ]
        else:
            tsuffix = tname.split('_')[0]
        lines += super(FortranEnumGeneratorValue, self).generate_item(
            name, members, tname=tname, tsuffix=tsuffix)
        if tname == 'int':
            lines[-1] = lines[-1].split(',')[0]
            lines += [
                '  end enum',
            ]
        lines += ['']
        return lines


def rename_source(directory, src_suffix, dst_suffix, ext):
    import shutil
    src_regex = os.path.join(directory, f"*_{src_suffix}{ext}")
    files = sorted(glob.glob(src_regex))
    if not files:
        raise Exception(f"No files found matching {src_regex}")
    for src in files:
        dst = src.replace(src_suffix, dst_suffix)
        shutil.move(src, dst)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "Generate enum source code & header files based on "
        "the values defined in a C/C++ source file")
    parser.add_argument("src", type=str,
                        help=("Source file that enums should be "
                              "extracted from"))
    parser.add_argument("--dst", type=str,
                        help=("Location where generated file should be "
                              "written"))
    parser.add_argument("--src-type", type=str,
                        choices=registered_classes('parser'),
                        default='param',
                        help="Type of parser to use on src file")
    parser.add_argument("--dst-type", type=str,
                        choices=registered_classes('generator'),
                        default='names',
                        help=("Type of generator that should be used "
                              "to create dst file"))
    parser.add_argument("--src-regex", action="store_true",
                        help=("Treat src as a regex to find file(s) to "
                              "parse"))
    parser.add_argument("--overwrite", action="store_true",
                        help="Overwrite any existing file(s)")
    parser.add_argument("--verbose", action="store_true",
                        help="Display the generated file content")
    parser.add_argument("--dry-run", action="store_true",
                        help="Run without writing any file(s)")
    parser.add_argument("--skip-children", action="store_true",
                        help="Don't generate the default child files")
    parser.add_argument("--root-include-dir", type=str,
                        help=("Root directory where include files are "
                              "located"))
    parser.add_argument("--prefix-with-type", action="store_true",
                        help="Prefix enums w/ their type")
    parser.add_argument("--prefix-by-split", type=str,
                        help=("Add prefixes to enum members by splitting "
                              "the name of the enum set by this string"))
    parser.add_argument("--rename-source", type=str,
                        help=("Rename source files in this directory "
                              "with the provided src suffix to use the "
                              "provided dst suffix"))
    for x in registered_classes('generator', return_classes=True):
        x.add_arguments(parser)
    args = parser.parse_args()
    if args.rename_source:
        src_cls = get_registered_class('parser', args.src_type)
        rename_source(args.rename_source, args.src, args.dst,
                      src_cls.file_extension)
    else:
        src = get_registered_class('parser', args.src_type)(
            args.src, verbose=args.verbose, is_regex=args.src_regex)
        dstcls = get_registered_class('generator', args.dst_type)
        kws = {}
        if args.prefix_by_split:
            assert not args.prefix_with_type
            kws['prefixes'] = src.prefix_by_split(args.prefix_by_split)
        elif args.prefix_with_type:
            kws['prefixes'] = {k: [f"{k}_"] for k in src.param.keys()}
        dst_children = dstcls.all_children()
        for x in registered_classes('generator', return_classes=True):
            if x.name not in [dstcls.name] + dst_children:
                continue
            x.get_arguments(args, kws, top_level=(x.name == args.dst_type))
        dst = dstcls(
            src, dst=args.dst, top_level=True, overwrite=args.overwrite,
            verbose=args.verbose, dry_run=args.dry_run,
            skip_children=args.skip_children,
            root_include_dir=args.root_include_dir, **kws)
