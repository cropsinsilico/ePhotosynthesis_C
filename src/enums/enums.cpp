// This code is generated by generate_enum.py and should not be
// modified directly
#include "enums/enums.hpp"
#include "enums/enums_utils.hpp"

namespace ePhotosynthesis {
  // Unspecialized enum
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::error_prefix() {
    std::string out;
    out += utils::get_enum_names<PARAM_TYPE>().find(param_type)->second;
    out += "[";
    out += utils::get_enum_names<MODULE>().find(module)->second;
    out += "]: ";
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::getName(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    it = names.find(x);
    if (it == names.end()) {
      throw std::runtime_error("Could not locate Name for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::getName(const typename ValueSetEnum<M, PT>::Type& x, const std::string& defaultV) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    it = names.find(x);
    if (it == names.end()) {
      return defaultV;
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  typename ValueSetEnum<M, PT>::Type ValueSetEnum<M, PT>::fromName(const std::string& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    for (it = names.begin(); it != names.end(); it++) {
      if (it->second == x) break;
    }
    if (it == names.end()) {
      throw std::runtime_error("Could not locate Name for '" + x + "'");
    }
    return it->first;
  };
  template<MODULE M, PARAM_TYPE PT>
  double ValueSetEnum<M, PT>::getDefault(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, double>::const_iterator it;
    it = defaults.find(x);
    if (it == defaults.end()) {
      throw std::runtime_error("Could not locate Default for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  double ValueSetEnum<M, PT>::getDefault(const typename ValueSetEnum<M, PT>::Type& x, const double& defaultV) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, double>::const_iterator it;
    it = defaults.find(x);
    if (it == defaults.end()) {
      return defaultV;
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  double ValueSetEnum<M, PT>::getDefaultC3(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, double>::const_iterator it;
    it = defaults_C3.find(x);
    if (it == defaults_C3.end()) {
      throw std::runtime_error("Could not locate DefaultC3 for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  double ValueSetEnum<M, PT>::getDefaultC3(const typename ValueSetEnum<M, PT>::Type& x, const double& defaultV) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, double>::const_iterator it;
    it = defaults_C3.find(x);
    if (it == defaults_C3.end()) {
      return defaultV;
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::getGlymaid(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    it = glymaids.find(x);
    if (it == glymaids.end()) {
      throw std::runtime_error("Could not locate Glymaid for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::getGlymaid(const typename ValueSetEnum<M, PT>::Type& x, const std::string& defaultV) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    it = glymaids.find(x);
    if (it == glymaids.end()) {
      return defaultV;
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  typename ValueSetEnum<M, PT>::Type ValueSetEnum<M, PT>::fromGlymaid(const std::string& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    for (it = glymaids.begin(); it != glymaids.end(); it++) {
      if (it->second == x) break;
    }
    if (it == glymaids.end()) {
      throw std::runtime_error("Could not locate Glymaid for '" + x + "'");
    }
    return it->first;
  };
  template<MODULE M, PARAM_TYPE PT>
  typename ValueSetEnum<M, PT>::Type ValueSetEnum<M, PT>::getAlias(const std::string& x) {
    typename std::map<std::string, typename ValueSetEnum<M, PT>::Type>::const_iterator it;
    it = aliases.find(x);
    if (it == aliases.end()) {
      throw std::runtime_error("Could not locate Alias for '" + x + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  typename ValueSetEnum<M, PT>::Type ValueSetEnum<M, PT>::getAlias(const std::string& x, const typename ValueSetEnum<M, PT>::Type& defaultV) {
    typename std::map<std::string, typename ValueSetEnum<M, PT>::Type>::const_iterator it;
    it = aliases.find(x);
    if (it == aliases.end()) {
      return defaultV;
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::getDocs(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    it = docs.find(x);
    if (it == docs.end()) {
      throw std::runtime_error("Could not locate Docs for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::string ValueSetEnum<M, PT>::getDocs(const typename ValueSetEnum<M, PT>::Type& x, const std::string& defaultV) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    it = docs.find(x);
    if (it == docs.end()) {
      return defaultV;
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  typename ValueSetEnum<M, PT>::Type ValueSetEnum<M, PT>::fromDocs(const std::string& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, std::string>::const_iterator it;
    for (it = docs.begin(); it != docs.end(); it++) {
      if (it->second == x) break;
    }
    if (it == docs.end()) {
      throw std::runtime_error("Could not locate Docs for '" + x + "'");
    }
    return it->first;
  };
  template<MODULE M, PARAM_TYPE PT>
  int ValueSetEnum<M, PT>::getValueFlag(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = value_flags.find(x);
    if (it == value_flags.end()) {
      throw std::runtime_error("Could not locate ValueFlag for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  bool ValueSetEnum<M, PT>::isSkipped(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = value_flags.find(x);
    if (it == value_flags.end()) return false;
    return (it->second & VALUE_FLAG_SKIPPED);
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkSkipped(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (!isSkipped(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNotSkipped(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (isSkipped(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countSkipped() {
    std::size_t out;
    out = 0;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = value_flags.begin(); it != value_flags.end(); it++) {
      if (it->second & VALUE_FLAG_SKIPPED) out++;
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countValueFlags() {
    std::size_t out;
    out = value_flags.size();
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::listSkipped() {
    std::vector<typename ValueSetEnum<M, PT>::Type> out;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = value_flags.begin(); it != value_flags.end(); it++){
      if (it->second & VALUE_FLAG_SKIPPED) {
        out.push_back(it->first);
      }
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::clearSkipped() {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::iterator it;
    for (it = value_flags.begin(); it != value_flags.end(); it++){
      it->second &= ~VALUE_FLAG_SKIPPED;
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::clearValueFlags() {
    value_flags.clear();
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::addSkipped(const typename ValueSetEnum<M, PT>::Type& x) {
    if (!isSkipped(x)) {
      typename std::map<typename ValueSetEnum<M, PT>::Type, int>::iterator it;
      it = value_flags.find(x);
      if (it == value_flags.end()) {
        value_flags.emplace(x, VALUE_FLAG_NONE);
        it = value_flags.find(x);
      }
      it->second |= VALUE_FLAG_SKIPPED;
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::addValueFlags(const typename ValueSetEnum<M, PT>::Type& x, const int& y) {
    value_flags.emplace(x, y);
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::removeSkipped(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::iterator it;
    it = value_flags.find(x);
    if (it != value_flags.end()) {
      it->second &= ~VALUE_FLAG_SKIPPED;
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::removeValueFlags(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::iterator it;
    it = value_flags.find(x);
    if (it != value_flags.end()) {
      value_flags.erase(it);
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::addMultipleValueFlags(const std::map<typename ValueSetEnum<M, PT>::Type, int>& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = x.begin(); it != x.end(); it++) {
      addValueFlags(it->first, it->second);
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::removeMultipleValueFlags(const std::map<typename ValueSetEnum<M, PT>::Type, int>& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = x.begin(); it != x.end(); it++) {
      removeValueFlags(it->first);
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  int ValueSetEnum<M, PT>::getStaticValueFlag(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = static_value_flags.find(x);
    if (it == static_value_flags.end()) {
      throw std::runtime_error("Could not locate StaticValueFlag for '" + names.find(x)->second + "'");
    }
    return it->second;
  };
  template<MODULE M, PARAM_TYPE PT>
  bool ValueSetEnum<M, PT>::isConstant(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = static_value_flags.find(x);
    if (it == static_value_flags.end()) return false;
    return (it->second & STATIC_VALUE_FLAG_CONST);
  };
  template<MODULE M, PARAM_TYPE PT>
  bool ValueSetEnum<M, PT>::isCalculated(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = static_value_flags.find(x);
    if (it == static_value_flags.end()) return false;
    return (it->second & STATIC_VALUE_FLAG_CALC);
  };
  template<MODULE M, PARAM_TYPE PT>
  bool ValueSetEnum<M, PT>::isNonvector(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = static_value_flags.find(x);
    if (it == static_value_flags.end()) return false;
    return (it->second & STATIC_VALUE_FLAG_NON_VECTOR);
  };
  template<MODULE M, PARAM_TYPE PT>
  bool ValueSetEnum<M, PT>::isResetone(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = static_value_flags.find(x);
    if (it == static_value_flags.end()) return false;
    return (it->second & STATIC_VALUE_FLAG_RESET_ONE);
  };
  template<MODULE M, PARAM_TYPE PT>
  bool ValueSetEnum<M, PT>::isInitonce(const typename ValueSetEnum<M, PT>::Type& x) {
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    it = static_value_flags.find(x);
    if (it == static_value_flags.end()) return false;
    return (it->second & STATIC_VALUE_FLAG_INIT_ONCE);
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkConstant(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (!isConstant(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkCalculated(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (!isCalculated(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNonvector(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (!isNonvector(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkResetone(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (!isResetone(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkInitonce(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (!isInitonce(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNotConstant(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (isConstant(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNotCalculated(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (isCalculated(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNotNonvector(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (isNonvector(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNotResetone(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (isResetone(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  void ValueSetEnum<M, PT>::checkNotInitonce(const typename ValueSetEnum<M, PT>::Type& x, const std::string& context) {
    if (isInitonce(x)) {
      throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countConstant() {
    std::size_t out;
    out = 0;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++) {
      if (it->second & STATIC_VALUE_FLAG_CONST) out++;
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countCalculated() {
    std::size_t out;
    out = 0;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++) {
      if (it->second & STATIC_VALUE_FLAG_CALC) out++;
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countNonvector() {
    std::size_t out;
    out = 0;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++) {
      if (it->second & STATIC_VALUE_FLAG_NON_VECTOR) out++;
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countResetone() {
    std::size_t out;
    out = 0;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++) {
      if (it->second & STATIC_VALUE_FLAG_RESET_ONE) out++;
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countInitonce() {
    std::size_t out;
    out = 0;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++) {
      if (it->second & STATIC_VALUE_FLAG_INIT_ONCE) out++;
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::size_t ValueSetEnum<M, PT>::countStaticValueFlags() {
    std::size_t out;
    out = static_value_flags.size();
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::listConstant() {
    std::vector<typename ValueSetEnum<M, PT>::Type> out;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
      if (it->second & STATIC_VALUE_FLAG_CONST) {
        out.push_back(it->first);
      }
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::listCalculated() {
    std::vector<typename ValueSetEnum<M, PT>::Type> out;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
      if (it->second & STATIC_VALUE_FLAG_CALC) {
        out.push_back(it->first);
      }
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::listNonvector() {
    std::vector<typename ValueSetEnum<M, PT>::Type> out;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
      if (it->second & STATIC_VALUE_FLAG_NON_VECTOR) {
        out.push_back(it->first);
      }
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::listResetone() {
    std::vector<typename ValueSetEnum<M, PT>::Type> out;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
      if (it->second & STATIC_VALUE_FLAG_RESET_ONE) {
        out.push_back(it->first);
      }
    }
    return out;
  };
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::listInitonce() {
    std::vector<typename ValueSetEnum<M, PT>::Type> out;
    typename std::map<typename ValueSetEnum<M, PT>::Type, int>::const_iterator it;
    for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
      if (it->second & STATIC_VALUE_FLAG_INIT_ONCE) {
        out.push_back(it->first);
      }
    }
    return out;
  };
  
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_CM, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_EPS, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_RA, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_VEL>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_COND>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_POOL>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_KE>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_MOD>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_RC>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_VARS>;
  template class ValueSetEnum<MODULE_ALL, PARAM_TYPE_VEL>;
}
