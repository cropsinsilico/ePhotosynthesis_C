// This code is generated by generate_enum.py and should not be
// modified directly
#include "enums/enums.hpp"


using namespace ePhotosynthesis;

template<> const std::vector<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_BF_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_BF_KE& x) {
  out << ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_BF_KE, std::string>& x) {
  ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_BF_KE, double>& x) {
  ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_BF_KE, int>& x) {
  ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_BF_KE>& x) {
  ValueSetEnum<MODULE_BF, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_BF_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_FIBF_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_FIBF_KE& x) {
  out << ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_FIBF_KE, std::string>& x) {
  ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_FIBF_KE, double>& x) {
  ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_FIBF_KE, int>& x) {
  ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_FIBF_KE>& x) {
  ValueSetEnum<MODULE_FIBF, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_FIBF_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_FI_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_FI_KE& x) {
  out << ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_FI_KE, std::string>& x) {
  ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_FI_KE, double>& x) {
  ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_FI_KE, int>& x) {
  ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_FI_KE>& x) {
  ValueSetEnum<MODULE_FI, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_FI_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_PR_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_PR_KE& x) {
  out << ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_PR_KE, std::string>& x) {
  ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_PR_KE, double>& x) {
  ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_PR_KE, int>& x) {
  ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_PR_KE>& x) {
  ValueSetEnum<MODULE_PR, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_PR_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_PS_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_PS_KE& x) {
  out << ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_PS_KE, std::string>& x) {
  ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_PS_KE, double>& x) {
  ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_PS_KE, int>& x) {
  ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_PS_KE>& x) {
  ValueSetEnum<MODULE_PS, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_PS_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::all = {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2FBPase, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2SBPase, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2PRK, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPase, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2RuACT, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2GAPDH, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2MDH, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPGPP, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEeFd2Thio};
template<> 
const std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::names = {
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2FBPase, "KEe2FBPase"},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2SBPase, "KEe2SBPase"},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2PRK   , "KEe2PRK"   },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPase, "KEe2ATPase"},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2RuACT , "KEe2RuACT" },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2GAPDH , "KEe2GAPDH" },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2MDH   , "KEe2MDH"   },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPGPP, "KEe2ATPGPP"},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEeFd2Thio, "KEeFd2Thio"},
};
template<> 
const std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::defaults = {
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2FBPase, 0.311167869},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2SBPase, 0.459194309},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2PRK   , 0.677638775},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPase, 1.0        },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2RuACT , 0.677638775},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2GAPDH , 0.044461692},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2MDH   , 0.044461692},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPGPP, 1.0        },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEeFd2Thio, 24776.0    },
};
template<> 
const std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::defaults_C3 = {
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2FBPase, 0.311167869},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2SBPase, 0.459194309},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2PRK   , 0.677638775},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPase, 1.0        },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2RuACT , 0.677638775},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2GAPDH , 0.044461692},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2MDH   , 0.044461692},
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPGPP, 1.0        },
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEeFd2Thio, 24776.0    },
};
template<> 
const std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::docs = {
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPase, "[CONST] 2.177727336 was set in code, but not used"},
};
template<> 
std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::static_value_flags = {
  {ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::SCOPED_ENUM_TYPE(Type)KEe2ATPase, (STATIC_VALUE_FLAG_CONST)},
};

// [BEGIN] EXPLICIT_SPEC_RROEA_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_RROEA_KE& x) {
  out << ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RROEA_KE, std::string>& x) {
  ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RROEA_KE, double>& x) {
  ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RROEA_KE, int>& x) {
  ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_RROEA_KE>& x) {
  ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_RROEA_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_REDOXREG_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_RedoxReg_KE& x) {
  out << ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RedoxReg_KE, std::string>& x) {
  ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RedoxReg_KE, double>& x) {
  ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RedoxReg_KE, int>& x) {
  ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_RedoxReg_KE>& x) {
  ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_REDOXREG_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_RUACT_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_RuACT_KE& x) {
  out << ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RuACT_KE, std::string>& x) {
  ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RuACT_KE, double>& x) {
  ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_RuACT_KE, int>& x) {
  ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_RuACT_KE>& x) {
  ValueSetEnum<MODULE_RuACT, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_RUACT_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_SUCS_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_SUCS_KE& x) {
  out << ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_SUCS_KE, std::string>& x) {
  ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_SUCS_KE, double>& x) {
  ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_SUCS_KE, int>& x) {
  ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_SUCS_KE>& x) {
  ValueSetEnum<MODULE_SUCS, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_SUCS_KE_UTILS


template<> const std::vector<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::all = {};
template<> 
const std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::names = {
};
template<> 
const std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::defaults = {
};
template<> 
const std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::defaults_C3 = {
};
template<> 
const std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::glymaids = {
};
template<> 
const std::map<std::string, ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::aliases = {
};
template<> 
const std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::docs = {
};
template<> 
std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::value_flags = {
};
template<> 
const std::map<ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::Type, int> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::static_value_flags = {
};

// [BEGIN] EXPLICIT_SPEC_XANCYCLE_KE_UTILS
#ifdef EPHOTO_USE_SCOPED_ENUM
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
std::ostream& operator<<(std::ostream& out, const ePhotosynthesis::ENUM_XanCycle_KE& x) {
  out << ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::getName(x);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_XanCycle_KE, std::string>& x) {
  ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_XanCycle_KE, double>& x) {
  ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::map<ePhotosynthesis::ENUM_XanCycle_KE, int>& x) {
  ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::print_map(x, out);
  return out;
}
std::ostream& operator<<(std::ostream& out, const std::vector<ePhotosynthesis::ENUM_XanCycle_KE>& x) {
  ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_KE>::print_vector(x, out);
  return out;
}
#endif // EPHOTO_USE_SCOPED_ENUM
// [END] EXPLICIT_SPEC_XANCYCLE_KE_UTILS


