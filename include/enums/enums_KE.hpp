// This code is generated by generate_enum.py and should not be
// modified directly
#pragma once

#ifdef EPHOTO_USE_SCOPED_ENUM
enum class ENUM_RROEA_KE : int {
    NONE           ,
    KEe2FBPase     ,
    KEe2SBPase     ,
    KEe2PRK        ,
    KEe2ATPase     ,  //!< [CONST] 2.177727336 was set in code, but not used
    KEe2RuACT      ,
    KEe2GAPDH      ,
    KEe2MDH        ,
    KEe2ATPGPP     ,
    KEeFd2Thio     ,
    MAX            ,
};
template<>
struct enum_helper<MODULE_RROEA, PARAM_TYPE_KE> {
  typedef ENUM_RROEA_KE type;
};
#else // EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type : int {
    NONE           ,
    KEe2FBPase     ,
    KEe2SBPase     ,
    KEe2PRK        ,
    KEe2ATPase     ,  //!< [CONST] 2.177727336 was set in code, but not used
    KEe2RuACT      ,
    KEe2GAPDH      ,
    KEe2MDH        ,
    KEe2ATPGPP     ,
    KEeFd2Thio     ,
    MAX            ,
};
#endif // EPHOTO_USE_SCOPED_ENUM
#define MEMBERS_RROEAKE		\
    NONE           ,		\
    KEe2FBPase     ,		\
    KEe2SBPase     ,		\
    KEe2PRK        ,		\
    KEe2ATPase     ,		\
    KEe2RuACT      ,		\
    KEe2GAPDH      ,		\
    KEe2MDH        ,		\
    KEe2ATPGPP     ,		\
    KEeFd2Thio     ,		\
    MAX
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::all;
template<> bool ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::state_updated;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::names;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::glymaids;
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::constant;
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::calculated;
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::nonvector;
template<> std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::skipped;
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::resetone;
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE>::initonce;

namespace KE {
  typedef ValueSetEnum<MODULE_RROEA, PARAM_TYPE_KE> RROEA;
}

#ifdef EPHOTO_USE_SCOPED_ENUM
enum class ENUM_NONE_KE : int {
    NONE   ,
    MAX    ,
};
template<>
struct enum_helper<MODULE_NONE, PARAM_TYPE_KE> {
  typedef ENUM_NONE_KE type;
};
#else // EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type : int {
    NONE   ,
    MAX    ,
};
#endif // EPHOTO_USE_SCOPED_ENUM
#define MEMBERS_NONEKE		\
    NONE   ,		\
    MAX
template<> const std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::all;
template<> bool ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::state_updated;
template<> const std::map<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::names;
template<> const std::map<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::glymaids;
template<> const std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::constant;
template<> const std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::calculated;
template<> const std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::nonvector;
template<> std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::skipped;
template<> const std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::resetone;
template<> const std::vector<typename ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE>::initonce;

namespace KE {
  typedef ValueSetEnum<MODULE_NONE, PARAM_TYPE_KE> NONE;
}

#ifdef EPHOTO_USE_SCOPED_ENUM
enum class ENUM_MAX_KE : int {
    NONE   ,
    MAX    ,
};
template<>
struct enum_helper<MODULE_MAX, PARAM_TYPE_KE> {
  typedef ENUM_MAX_KE type;
};
#else // EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type : int {
    NONE   ,
    MAX    ,
};
#endif // EPHOTO_USE_SCOPED_ENUM
#define MEMBERS_MAXKE		\
    NONE   ,		\
    MAX
template<> const std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::all;
template<> bool ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::state_updated;
template<> const std::map<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::names;
template<> const std::map<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type, double> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type, std::string> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::glymaids;
template<> const std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::constant;
template<> const std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::calculated;
template<> const std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::nonvector;
template<> std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::skipped;
template<> const std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::resetone;
template<> const std::vector<typename ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::Type> ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE>::initonce;

namespace KE {
  typedef ValueSetEnum<MODULE_MAX, PARAM_TYPE_KE> MAX;
}

