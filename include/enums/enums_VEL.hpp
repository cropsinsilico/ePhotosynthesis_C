// This code is generated by generate_enum.py and should not be
// modified directly
#pragma once

#include "enums/enums_helpers.hpp"

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_BF_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_BFVel
};
typedef ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type ENUM_BF_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_BF_VEL> {
  typedef ENUM_BF_VEL type;
  static const MODULE module = MODULE_BF;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_BF_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_BF_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_BF_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_BF_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_BF_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_BF, PARAM_TYPE_VEL> BF;
  }
  // [END] SPECIALIZED_TYPEDEF_BF_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_FIBF_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_FIBFVel
};
typedef ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type ENUM_FIBF_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_FIBF_VEL> {
  typedef ENUM_FIBF_VEL type;
  static const MODULE module = MODULE_FIBF;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_FIBF_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_FIBF_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_FIBF_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_FIBF_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_FIBF_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_FIBF, PARAM_TYPE_VEL> FIBF;
  }
  // [END] SPECIALIZED_TYPEDEF_FIBF_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_FI_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_FIVel
};
typedef ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type ENUM_FI_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_FI_VEL> {
  typedef ENUM_FI_VEL type;
  static const MODULE module = MODULE_FI;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_FI_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_FI_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_FI_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_FI_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_FI_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_FI, PARAM_TYPE_VEL> FI;
  }
  // [END] SPECIALIZED_TYPEDEF_FI_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_PR_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_PRVel
};
typedef ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type ENUM_PR_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_PR_VEL> {
  typedef ENUM_PR_VEL type;
  static const MODULE module = MODULE_PR;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_PR_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_PR_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_PR_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_PR_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_PR_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_PR, PARAM_TYPE_VEL> PR;
  }
  // [END] SPECIALIZED_TYPEDEF_PR_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_PS_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_PSVel
};
typedef ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type ENUM_PS_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_PS_VEL> {
  typedef ENUM_PS_VEL type;
  static const MODULE module = MODULE_PS;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_PS_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_PS_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_PS_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_PS_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_PS_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_PS, PARAM_TYPE_VEL> PS;
  }
  // [END] SPECIALIZED_TYPEDEF_PS_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_RROEA_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_RROEAVel
};
typedef ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type ENUM_RROEA_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_RROEA_VEL> {
  typedef ENUM_RROEA_VEL type;
  static const MODULE module = MODULE_RROEA;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_RROEA_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_RROEA_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_RROEA_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_RROEA_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_RROEA_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_RROEA, PARAM_TYPE_VEL> RROEA;
  }
  // [END] SPECIALIZED_TYPEDEF_RROEA_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_REDOXREG_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_RedoxRegVel
};
typedef ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type ENUM_RedoxReg_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_RedoxReg_VEL> {
  typedef ENUM_RedoxReg_VEL type;
  static const MODULE module = MODULE_RedoxReg;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_REDOXREG_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_REDOXREG_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_RedoxReg_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_REDOXREG_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_REDOXREG_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_VEL> RedoxReg;
  }
  // [END] SPECIALIZED_TYPEDEF_REDOXREG_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_RUACT_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_RuACTVel
};
typedef ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type ENUM_RuACT_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_RuACT_VEL> {
  typedef ENUM_RuACT_VEL type;
  static const MODULE module = MODULE_RuACT;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_RUACT_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_RUACT_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_RuACT_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_RUACT_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_RUACT_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_RuACT, PARAM_TYPE_VEL> RuACT;
  }
  // [END] SPECIALIZED_TYPEDEF_RUACT_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_SUCS_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_SUCSVel
};
typedef ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type ENUM_SUCS_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_SUCS_VEL> {
  typedef ENUM_SUCS_VEL type;
  static const MODULE module = MODULE_SUCS;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_SUCS_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_SUCS_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_SUCS_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_SUCS_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_SUCS_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_SUCS, PARAM_TYPE_VEL> SUCS;
  }
  // [END] SPECIALIZED_TYPEDEF_SUCS_VEL
  
}

namespace ePhotosynthesis {
// [BEGIN] EXPLICIT_SPECIALIZATION_XANCYCLE_VEL
#ifndef EPHOTO_USE_SCOPED_ENUM
template<>
enum ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type : int {
  MEMBERS_XanCycleVel
};
typedef ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type ENUM_XanCycle_VEL;
#endif // EPHOTO_USE_SCOPED_ENUM
template<> const std::vector<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::all;
template<> const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::names;
template<> const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::defaults;
template<> const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, double> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::defaults_C3;
template<> const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::glymaids;
template<> const std::map<std::string, typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::aliases;
template<> const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::docs;
template<> std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::value_flags;
template<> const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::Type, int> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::static_value_flags;
template<>
struct enum_helper_inv<ENUM_XanCycle_VEL> {
  typedef ENUM_XanCycle_VEL type;
  static const MODULE module = MODULE_XanCycle;
  static const PARAM_TYPE param_type = PARAM_TYPE_VEL;
};
// [END] EXPLICIT_SPECIALIZATION_XANCYCLE_VEL

// [BEGIN] EXPLICIT_SPECIALIZATION_XANCYCLE_VEL_UTILS
// Definition of explicitly specialized enum class 
//   utility methods. This causes instantiation of the 
//   specialized class and must come after explicit 
//   specialization of the class (and class members)
/**
  Serialize an enum to an output stream
  \param[in,out] out Output stream
  \param[in] x Key to serialize
  \return Updated stream
*/
std::ostream& operator<<(std::ostream& out, const ENUM_XanCycle_VEL& x);
/**
  Get a prefix for errors describing the class
  \return Prefix
*/
template<>
std::string ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL>::error_prefix();
// [END] EXPLICIT_SPECIALIZATION_XANCYCLE_VEL_UTILS
}

namespace ePhotosynthesis {
  // [BEGIN] SPECIALIZED_TYPEDEF_XANCYCLE_VEL
  namespace VEL {
    typedef ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_VEL> XanCycle;
  }
  // [END] SPECIALIZED_TYPEDEF_XANCYCLE_VEL
  
}


