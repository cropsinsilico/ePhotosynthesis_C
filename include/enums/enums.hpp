// This code is generated by generate_enum.py and should not be
// modified directly
#pragma once

#include <string>
#include <map>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#ifdef _MSC_VER
// There is a bug in the MSVC compiler where it does not allow
//   declaration of a specialized class member enum
//   https://developercommunity.visualstudio.com/t/Explicit-specialization-of-member-enumer/10609934
#define EPHOTO_USE_SCOPED_ENUM 1
#endif // _MSC_VER
#ifdef EPHOTO_USE_SCOPED_ENUM
#define SCOPED_ENUM_TYPE(name) name::
#else // EPHOTO_USE_SCOPED_ENUM
#define SCOPED_ENUM_TYPE(name)
#endif // EPHOTO_USE_SCOPED_ENUM
#include "enums/enums_helpers.hpp"

namespace ePhotosynthesis {
  // VALUE_FLAG enum
  #define MEMBERS_VALUE		\
      VALUE_FLAG_NONE                ,		\
      VALUE_FLAG_SKIPPED             ,		\
      VALUE_FLAG_MAX
  #define MEMBER_NAMES_VALUE		\
      SKIPPED
  enum VALUE_FLAG : int {
      VALUE_FLAG_NONE    = 0x00000000,
      VALUE_FLAG_SKIPPED = 0x00000001,
      VALUE_FLAG_MAX     = 0x00000002,
  };
  static const std::vector<VALUE_FLAG> ALL_VALUE_FLAG = {VALUE_FLAG_SKIPPED};  /**< All enum values */
  
  // STATIC_VALUE_FLAG enum
  #define MEMBERS_STATIC_VALUE		\
      STATIC_VALUE_FLAG_NONE                   ,		\
      STATIC_VALUE_FLAG_CONST                  ,		\
      STATIC_VALUE_FLAG_CALC                   ,		\
      STATIC_VALUE_FLAG_NON_VECTOR             ,		\
      STATIC_VALUE_FLAG_RESET_ONE              ,		\
      STATIC_VALUE_FLAG_INIT_ONCE              ,		\
      STATIC_VALUE_FLAG_MAX
  #define MEMBER_NAMES_STATIC_VALUE		\
      CONST                  ,		\
      CALC                   ,		\
      NON_VECTOR             ,		\
      RESET_ONE              ,		\
      INIT_ONCE
  enum STATIC_VALUE_FLAG : int {
      STATIC_VALUE_FLAG_NONE       = 0x00000000,
      STATIC_VALUE_FLAG_CONST      = 0x00000001,
      STATIC_VALUE_FLAG_CALC       = 0x00000002,
      STATIC_VALUE_FLAG_NON_VECTOR = 0x00000004,
      STATIC_VALUE_FLAG_RESET_ONE  = 0x00000008,
      STATIC_VALUE_FLAG_INIT_ONCE  = 0x00000010,
      STATIC_VALUE_FLAG_MAX        = 0x00000020,
  };
  static const std::vector<STATIC_VALUE_FLAG> ALL_STATIC_VALUE_FLAG = {STATIC_VALUE_FLAG_CONST, STATIC_VALUE_FLAG_CALC, STATIC_VALUE_FLAG_NON_VECTOR, STATIC_VALUE_FLAG_RESET_ONE, STATIC_VALUE_FLAG_INIT_ONCE};  /**< All enum values */
  
  // Utility for getting module id from enum type
  template<typename T>
  MODULE get_enum_module() {
    return T::MODULE;
  }
  
  // Utility for getting param_type from enum type
  template<typename T>
  PARAM_TYPE get_enum_param_type() {
    return T::PARAM_TYPE;
  }
  
  // Utility for getting names from enum
  template<typename T>
  const std::map<T, std::string>& get_enum_names() {
    static const std::map<T, std::string> result;
    throw std::runtime_error("No enum names collection could be found");
    return result;
  }
  template<>
  inline const std::map<MODULE, std::string>& get_enum_names<MODULE>() {
    static const std::map<MODULE, std::string> collection = {
      {MODULE_BF      , "BF"      },
      {MODULE_CM      , "CM"      },
      {MODULE_DynaPS  , "DynaPS"  },
      {MODULE_EPS     , "EPS"     },
      {MODULE_FIBF    , "FIBF"    },
      {MODULE_FI      , "FI"      },
      {MODULE_PR      , "PR"      },
      {MODULE_PS      , "PS"      },
      {MODULE_PS_PR   , "PS_PR"   },
      {MODULE_RA      , "RA"      },
      {MODULE_RROEA   , "RROEA"   },
      {MODULE_RedoxReg, "RedoxReg"},
      {MODULE_RuACT   , "RuACT"   },
      {MODULE_SUCS    , "SUCS"    },
      {MODULE_XanCycle, "XanCycle"},
      {MODULE_trDynaPS, "trDynaPS"},
      {MODULE_ALL     , "ALL"     },
    };
    return collection;
  }
  template<>
  inline const std::map<PARAM_TYPE, std::string>& get_enum_names<PARAM_TYPE>() {
    static const std::map<PARAM_TYPE, std::string> collection = {
      {PARAM_TYPE_COND, "COND"},
      {PARAM_TYPE_POOL, "POOL"},
      {PARAM_TYPE_KE  , "KE"  },
      {PARAM_TYPE_MOD , "MOD" },
      {PARAM_TYPE_RC  , "RC"  },
      {PARAM_TYPE_VARS, "VARS"},
      {PARAM_TYPE_VEL , "VEL" },
    };
    return collection;
  }
  // Utility for getting values from enum
  template<typename T>
  const std::map<T, double>& get_enum_defaults() {
    static const std::map<T, double> result;
    throw std::runtime_error("No enum defaults collection could be found");
    return result;
  }
  // Utility for getting alternate_values from enum
  template<typename T>
  const std::map<T, double>& get_enum_defaults_C3() {
    static const std::map<T, double> result;
    throw std::runtime_error("No enum defaults_C3 collection could be found");
    return result;
  }
  // Utility for getting glymaids from enum
  template<typename T>
  const std::map<T, std::string>& get_enum_glymaids() {
    static const std::map<T, std::string> result;
    throw std::runtime_error("No enum glymaids collection could be found");
    return result;
  }
  // Utility for getting aliases from enum
  template<typename T>
  const std::map<std::string, T>& get_enum_aliases() {
    static const std::map<std::string, T> result;
    throw std::runtime_error("No enum aliases collection could be found");
    return result;
  }
  // Utility for getting docs from enum
  template<typename T>
  const std::map<T, std::string>& get_enum_docs() {
    static const std::map<T, std::string> result;
    throw std::runtime_error("No enum docs collection could be found");
    return result;
  }
  // Utility for getting value_flags from enum
  template<typename T>
  std::map<T, int>& get_enum_value_flags() {
    static std::map<T, int> result;
    throw std::runtime_error("No enum value_flags collection could be found");
    return result;
  }
  // Utility for getting static_value_flags from enum
  template<typename T>
  const std::map<T, int>& get_enum_static_value_flags() {
    static const std::map<T, int> result;
    throw std::runtime_error("No enum static_value_flags collection could be found");
    return result;
  }
  // Unspecialized enum
  template<MODULE M, PARAM_TYPE PT>
  class ValueSetEnum {
  public:
    #ifdef EPHOTO_USE_SCOPED_ENUM
    typedef typename enum_helper<M, PT>::type Type;
    #else // EPHOTO_USE_SCOPED_ENUM
    enum Type : int;
    #endif // EPHOTO_USE_SCOPED_ENUM
    static const MODULE module;
    static const PARAM_TYPE param_type;
    static const std::vector<Type> all;  /**< All enum values */
    static const std::map<Type, std::string> names;  /**< Names for values */
    static const std::map<Type, double> defaults;  /**< Defaults for values */
    static const std::map<Type, double> defaults_C3;  /**< Defaults_C3 for values */
    static const std::map<Type, std::string> glymaids;  /**< Glymaids for values */
    static const std::map<std::string, Type> aliases;  /**< Aliases for values */
    static const std::map<Type, std::string> docs;  /**< Docs for values */
    static std::map<Type, int> value_flags;  /**< Value_Flags for values */
    static const std::map<Type, int> static_value_flags;  /**< Static_Value_Flags for values */
    /**
      Get a prefix for errors describing the class
      \return Prefix
    */
    static std::string error_prefix() {
      std::string out;
      out += get_enum_names<PARAM_TYPE>().find(param_type)->second;
      out += "[";
      out += get_enum_names<MODULE>().find(module)->second;
      out += "]: ";
      return out;
    }
    /**
      Get the name value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static std::string getName(const Type& x) {
      typename std::map<Type, std::string>::const_iterator it;
      it = names.find(x);
      if (it == names.end()) {
        throw std::runtime_error("Could not locate Name for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the name value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static std::string getName(const Type& x, const std::string& defaultV) {
      typename std::map<Type, std::string>::const_iterator it;
      it = names.find(x);
      if (it == names.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Get the enum key corresponding to a name values
      \param[in] x Value to get key for
      \return Key
    */
    static Type fromName(const std::string& x) {
      typename std::map<Type, std::string>::const_iterator it;
      for (it = names.begin(); it != names.end(); it++) {
        if (it->second == x) break;
      }
      if (it == names.end()) {
        throw std::runtime_error("Could not locate Name for '" + x + "'");
      }
      return it->first;
    }
    /**
      Print the contents of a collection
      \param[in] collection Object to print
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    template<typename T>
    static std::ostream& print_map(const std::map<Type, T>& collection, std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      const std::string space(tab * 4, ' ');
      typename std::map<Type, T>::const_iterator it;
      for (it = collection.begin(); it != collection.end(); it++) {
        out << space << "  " << names.find(it->first)->second << "	" << it->second << std::endl;
      }
      return out;
    }
    /**
      Serialize a collection to a string
      \param[in] collection Object to serialize
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    template<typename T>
    static std::string string_map(const std::map<Type, T>& collection, const unsigned int tab = 0) {
      std::ostringstream oss;
      print_map(collection, oss, tab);
      return oss.str();
    }
    /**
      Print the contents of defaults
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printDefaults(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(defaults, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of defaults
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringDefaults(const unsigned int tab = 0) {
      return string_map(defaults, tab);
    }
    /**
      Get the default value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static double getDefault(const Type& x) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults.find(x);
      if (it == defaults.end()) {
        throw std::runtime_error("Could not locate Default for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the default value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static double getDefault(const Type& x, const double& defaultV) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults.find(x);
      if (it == defaults.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of defaults_C3
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printDefaultsC3(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(defaults_C3, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of defaults_C3
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringDefaultsC3(const unsigned int tab = 0) {
      return string_map(defaults_C3, tab);
    }
    /**
      Get the defaultc3 value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static double getDefaultC3(const Type& x) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults_C3.find(x);
      if (it == defaults_C3.end()) {
        throw std::runtime_error("Could not locate DefaultC3 for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the defaultc3 value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static double getDefaultC3(const Type& x, const double& defaultV) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults_C3.find(x);
      if (it == defaults_C3.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of glymaids
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printGlymaids(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(glymaids, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of glymaids
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringGlymaids(const unsigned int tab = 0) {
      return string_map(glymaids, tab);
    }
    /**
      Get the glymaid value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static std::string getGlymaid(const Type& x) {
      typename std::map<Type, std::string>::const_iterator it;
      it = glymaids.find(x);
      if (it == glymaids.end()) {
        throw std::runtime_error("Could not locate Glymaid for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the glymaid value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static std::string getGlymaid(const Type& x, const std::string& defaultV) {
      typename std::map<Type, std::string>::const_iterator it;
      it = glymaids.find(x);
      if (it == glymaids.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Get the enum key corresponding to a glymaid values
      \param[in] x Value to get key for
      \return Key
    */
    static Type fromGlymaid(const std::string& x) {
      typename std::map<Type, std::string>::const_iterator it;
      for (it = glymaids.begin(); it != glymaids.end(); it++) {
        if (it->second == x) break;
      }
      if (it == glymaids.end()) {
        throw std::runtime_error("Could not locate Glymaid for '" + x + "'");
      }
      return it->first;
    }
    /**
      Print the contents of aliases
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printAliases(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(aliases, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of aliases
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringAliases(const unsigned int tab = 0) {
      return string_map(aliases, tab);
    }
    /**
      Get the alias value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static Type getAlias(const std::string& x) {
      typename std::map<std::string, Type>::const_iterator it;
      it = aliases.find(x);
      if (it == aliases.end()) {
        throw std::runtime_error("Could not locate Alias for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the alias value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static Type getAlias(const std::string& x, const Type& defaultV) {
      typename std::map<std::string, Type>::const_iterator it;
      it = aliases.find(x);
      if (it == aliases.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of docs
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printDocs(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(docs, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of docs
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringDocs(const unsigned int tab = 0) {
      return string_map(docs, tab);
    }
    /**
      Get the docs value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static std::string getDocs(const Type& x) {
      typename std::map<Type, std::string>::const_iterator it;
      it = docs.find(x);
      if (it == docs.end()) {
        throw std::runtime_error("Could not locate Docs for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the docs value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static std::string getDocs(const Type& x, const std::string& defaultV) {
      typename std::map<Type, std::string>::const_iterator it;
      it = docs.find(x);
      if (it == docs.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Get the enum key corresponding to a docs values
      \param[in] x Value to get key for
      \return Key
    */
    static Type fromDocs(const std::string& x) {
      typename std::map<Type, std::string>::const_iterator it;
      for (it = docs.begin(); it != docs.end(); it++) {
        if (it->second == x) break;
      }
      if (it == docs.end()) {
        throw std::runtime_error("Could not locate Docs for '" + x + "'");
      }
      return it->first;
    }
    /**
      Print the contents of a collection
      \param[in] collection Object to print
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& print_vector(const std::vector<Type>& collection, std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      const std::string space(tab * 4, ' ');
      out << space << "[";
      typename std::vector<Type>::const_iterator it;
      for (it = collection.begin(); it != collection.end(); it++) {
        out << names.find((*(it)))->second << ",";
      }
      out << "]";
      return out;
    }
    /**
      Serialize a collection to a string
      \param[in] collection Object to serialize
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string string_vector(const std::vector<Type>& collection, const unsigned int tab = 0) {
      std::ostringstream oss;
      print_vector(collection, oss, tab);
      return oss.str();
    }
    /**
      Print the contents of value_flags
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printValueFlags(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(value_flags, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of skipped
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringSkipped(const unsigned int tab = 0) {
      return string_vector(listSkipped(), tab);
    }
    /**
      Serialize the contents of value_flags
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringValueFlags(const unsigned int tab = 0) {
      return string_map(value_flags, tab);
    }
    /**
      Get the valueflag value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static int getValueFlag(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = value_flags.find(x);
      if (it == value_flags.end()) {
        throw std::runtime_error("Could not locate ValueFlag for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Check if a key is in value_flags
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isSkipped(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = value_flags.find(x);
      if (it == value_flags.end()) return false;
      return (it->second & VALUE_FLAG_SKIPPED);
    }
    /**
      Throw an error if a key is not in value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkSkipped(const Type& x, const std::string& context = "") {
      if (!isSkipped(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in value_flags");
      }
    }
    /**
      Throw an error if a key is in value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotSkipped(const Type& x, const std::string& context = "") {
      if (isSkipped(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in value_flags");
      }
    }
    /**
      Get the number of elements in value_flags with VALUE_FLAG_SKIPPED set.
      \return Number of elements with VALUE_FLAG_SKIPPED set.
    */
    static std::size_t countSkipped() {
      std::size_t out;
      out = 0;
      typename std::map<Type, int>::const_iterator it;
      for (it = value_flags.begin(); it != value_flags.end(); it++){
        if (it->second & VALUE_FLAG_SKIPPED) out++;
      }
      return out;
    }
    /**
      Get the number of elements in value_flags.
      \return Number of elements.
    */
    static std::size_t countValueFlags() {
      std::size_t out;
      out = value_flags.size();
      return out;
    }
    /**
      Get the set of elements in value_flags with VALUE_FLAG_SKIPPED set.
      \return Set of elements.
    */
    static std::vector<Type> listSkipped() {
      std::vector<Type> out;
      typename std::map<Type, int>::const_iterator it;
      for (it = value_flags.begin(); it != value_flags.end(); it++){
        if (it->second & VALUE_FLAG_SKIPPED) {
          out.push_back(it->first);
        }
      }
      return out;
    }
    /**
      Remove all VALUE_FLAG_SKIPPED flags from value_flags
    */
    static void clearSkipped() {
      typename std::map<Type, int>::iterator it;
      for (it = value_flags.begin(); it != value_flags.end(); it++){
        it->second &= ~VALUE_FLAG_SKIPPED;
      }
    }
    /**
      Remove all entries from value_flags
    */
    static void clearValueFlags() {
      value_flags.clear();
    }
    /**
      Add an element to value_flags if it is not already present
      \param[in] x Key to add
    */
    static void addSkipped(const Type& x) {
      if (!isSkipped(x)) {
        typename std::map<Type, int>::iterator it;
        it = value_flags.find(x);
        if (it == value_flags.end()) {
          value_flags.emplace(x, VALUE_FLAG_NONE);
          it = value_flags.find(x);
        }
        it->second |= VALUE_FLAG_SKIPPED;
      }
    }
    /**
      Add an element to value_flags if it is not already present
      \param[in] x Key to add
      \param y Value to add for x
    */
    static void addValueFlags(const Type& x, const int& y) {
      value_flags.emplace(x, y);
    }
    /**
      Remove an element from value_flags
      \param[in] x Key to remove
    */
    static void removeSkipped(const Type& x) {
      typename std::map<Type, int>::iterator it;
      it = value_flags.find(x);
      if (it != value_flags.end()) {
        it->second &= ~VALUE_FLAG_SKIPPED;
      }
    }
    /**
      Remove an element from value_flags
      \param[in] x Key to remove
    */
    static void removeValueFlags(const Type& x) {
      typename std::map<Type, int>::iterator it;
      it = value_flags.find(x);
      if (it != value_flags.end()) {
        value_flags.erase(it);
      }
    }
    /**
      Add multiple elements to value_flags if they are not already present
      \param[in] x Elements to add
    */
    static void addMultipleValueFlags(const std::map<Type, int>& x) {
      typename std::map<Type, int>::const_iterator it;
      for (it = x.begin(); it != x.end(); it++) {
        addValueFlags(it->first, it->second);
      }
    }
    /**
      Remove multiple elements to value_flags if they are not already present
      \param[in] x Elements to add
    */
    static void removeMultipleValueFlags(const std::map<Type, int>& x) {
      typename std::map<Type, int>::const_iterator it;
      for (it = x.begin(); it != x.end(); it++) {
        removeValueFlags(it->first);
      }
    }
    /**
      Print the contents of static_value_flags
      \param[in,out] out Stream to print to
      \param[in] includePrefixes If true, the module & 
        parameter type prefixes will be added to the member 
        names.
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printStaticValueFlags(std::ostream& out, bool includePrefixes = false, const unsigned int tab = 0) {
      return print_map(static_value_flags, out, includePrefixes, tab);
    }
    /**
      Serialize the contents of constant
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringConstant(const unsigned int tab = 0) {
      return string_vector(listConstant(), tab);
    }
    /**
      Serialize the contents of calculated
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringCalculated(const unsigned int tab = 0) {
      return string_vector(listCalculated(), tab);
    }
    /**
      Serialize the contents of nonvector
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringNonvector(const unsigned int tab = 0) {
      return string_vector(listNonvector(), tab);
    }
    /**
      Serialize the contents of resetone
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringResetone(const unsigned int tab = 0) {
      return string_vector(listResetone(), tab);
    }
    /**
      Serialize the contents of initonce
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringInitonce(const unsigned int tab = 0) {
      return string_vector(listInitonce(), tab);
    }
    /**
      Serialize the contents of static_value_flags
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringStaticValueFlags(const unsigned int tab = 0) {
      return string_map(static_value_flags, tab);
    }
    /**
      Get the staticvalueflag value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static int getStaticValueFlag(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = static_value_flags.find(x);
      if (it == static_value_flags.end()) {
        throw std::runtime_error("Could not locate StaticValueFlag for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Check if a key is in static_value_flags
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isConstant(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = static_value_flags.find(x);
      if (it == static_value_flags.end()) return false;
      return (it->second & STATIC_VALUE_FLAG_CONST);
    }
    /**
      Check if a key is in static_value_flags
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isCalculated(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = static_value_flags.find(x);
      if (it == static_value_flags.end()) return false;
      return (it->second & STATIC_VALUE_FLAG_CALC);
    }
    /**
      Check if a key is in static_value_flags
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isNonvector(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = static_value_flags.find(x);
      if (it == static_value_flags.end()) return false;
      return (it->second & STATIC_VALUE_FLAG_NON_VECTOR);
    }
    /**
      Check if a key is in static_value_flags
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isResetone(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = static_value_flags.find(x);
      if (it == static_value_flags.end()) return false;
      return (it->second & STATIC_VALUE_FLAG_RESET_ONE);
    }
    /**
      Check if a key is in static_value_flags
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isInitonce(const Type& x) {
      typename std::map<Type, int>::const_iterator it;
      it = static_value_flags.find(x);
      if (it == static_value_flags.end()) return false;
      return (it->second & STATIC_VALUE_FLAG_INIT_ONCE);
    }
    /**
      Throw an error if a key is not in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkConstant(const Type& x, const std::string& context = "") {
      if (!isConstant(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
      }
    }
    /**
      Throw an error if a key is not in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkCalculated(const Type& x, const std::string& context = "") {
      if (!isCalculated(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
      }
    }
    /**
      Throw an error if a key is not in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNonvector(const Type& x, const std::string& context = "") {
      if (!isNonvector(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
      }
    }
    /**
      Throw an error if a key is not in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkResetone(const Type& x, const std::string& context = "") {
      if (!isResetone(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
      }
    }
    /**
      Throw an error if a key is not in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkInitonce(const Type& x, const std::string& context = "") {
      if (!isInitonce(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in static_value_flags");
      }
    }
    /**
      Throw an error if a key is in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotConstant(const Type& x, const std::string& context = "") {
      if (isConstant(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
      }
    }
    /**
      Throw an error if a key is in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotCalculated(const Type& x, const std::string& context = "") {
      if (isCalculated(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
      }
    }
    /**
      Throw an error if a key is in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotNonvector(const Type& x, const std::string& context = "") {
      if (isNonvector(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
      }
    }
    /**
      Throw an error if a key is in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotResetone(const Type& x, const std::string& context = "") {
      if (isResetone(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
      }
    }
    /**
      Throw an error if a key is in static_value_flags
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotInitonce(const Type& x, const std::string& context = "") {
      if (isInitonce(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in static_value_flags");
      }
    }
    /**
      Get the number of elements in static_value_flags with STATIC_VALUE_FLAG_CONST set.
      \return Number of elements with STATIC_VALUE_FLAG_CONST set.
    */
    static std::size_t countConstant() {
      std::size_t out;
      out = 0;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_CONST) out++;
      }
      return out;
    }
    /**
      Get the number of elements in static_value_flags with STATIC_VALUE_FLAG_CALC set.
      \return Number of elements with STATIC_VALUE_FLAG_CALC set.
    */
    static std::size_t countCalculated() {
      std::size_t out;
      out = 0;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_CALC) out++;
      }
      return out;
    }
    /**
      Get the number of elements in static_value_flags with STATIC_VALUE_FLAG_NON_VECTOR set.
      \return Number of elements with STATIC_VALUE_FLAG_NON_VECTOR set.
    */
    static std::size_t countNonvector() {
      std::size_t out;
      out = 0;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_NON_VECTOR) out++;
      }
      return out;
    }
    /**
      Get the number of elements in static_value_flags with STATIC_VALUE_FLAG_RESET_ONE set.
      \return Number of elements with STATIC_VALUE_FLAG_RESET_ONE set.
    */
    static std::size_t countResetone() {
      std::size_t out;
      out = 0;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_RESET_ONE) out++;
      }
      return out;
    }
    /**
      Get the number of elements in static_value_flags with STATIC_VALUE_FLAG_INIT_ONCE set.
      \return Number of elements with STATIC_VALUE_FLAG_INIT_ONCE set.
    */
    static std::size_t countInitonce() {
      std::size_t out;
      out = 0;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_INIT_ONCE) out++;
      }
      return out;
    }
    /**
      Get the number of elements in static_value_flags.
      \return Number of elements.
    */
    static std::size_t countStaticValueFlags() {
      std::size_t out;
      out = static_value_flags.size();
      return out;
    }
    /**
      Get the set of elements in static_value_flags with STATIC_VALUE_FLAG_CONST set.
      \return Set of elements.
    */
    static std::vector<Type> listConstant() {
      std::vector<Type> out;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_CONST) {
          out.push_back(it->first);
        }
      }
      return out;
    }
    /**
      Get the set of elements in static_value_flags with STATIC_VALUE_FLAG_CALC set.
      \return Set of elements.
    */
    static std::vector<Type> listCalculated() {
      std::vector<Type> out;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_CALC) {
          out.push_back(it->first);
        }
      }
      return out;
    }
    /**
      Get the set of elements in static_value_flags with STATIC_VALUE_FLAG_NON_VECTOR set.
      \return Set of elements.
    */
    static std::vector<Type> listNonvector() {
      std::vector<Type> out;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_NON_VECTOR) {
          out.push_back(it->first);
        }
      }
      return out;
    }
    /**
      Get the set of elements in static_value_flags with STATIC_VALUE_FLAG_RESET_ONE set.
      \return Set of elements.
    */
    static std::vector<Type> listResetone() {
      std::vector<Type> out;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_RESET_ONE) {
          out.push_back(it->first);
        }
      }
      return out;
    }
    /**
      Get the set of elements in static_value_flags with STATIC_VALUE_FLAG_INIT_ONCE set.
      \return Set of elements.
    */
    static std::vector<Type> listInitonce() {
      std::vector<Type> out;
      typename std::map<Type, int>::const_iterator it;
      for (it = static_value_flags.begin(); it != static_value_flags.end(); it++){
        if (it->second & STATIC_VALUE_FLAG_INIT_ONCE) {
          out.push_back(it->first);
        }
      }
      return out;
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  const MODULE ValueSetEnum<M, PT>::module = M;
  template<MODULE M, PARAM_TYPE PT>
  const PARAM_TYPE ValueSetEnum<M, PT>::param_type = PT;
  template<MODULE M, PARAM_TYPE PT>
  const std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::all = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, std::string> ValueSetEnum<M, PT>::names = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, double> ValueSetEnum<M, PT>::defaults = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, double> ValueSetEnum<M, PT>::defaults_C3 = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, std::string> ValueSetEnum<M, PT>::glymaids = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<std::string, typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::aliases = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, std::string> ValueSetEnum<M, PT>::docs = {};
  template<MODULE M, PARAM_TYPE PT>
  std::map<typename ValueSetEnum<M, PT>::Type, int> ValueSetEnum<M, PT>::value_flags = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, int> ValueSetEnum<M, PT>::static_value_flags = {};
  
  
  // Utility for getting enum type from module & param_type
  #define MODULE2Enum ValueSetEnum
  // Utility for getting name from enum
  template<typename T>
  std::string get_enum_name(const T& k) {
    return get_enum_names<T>().find(k)->second;
  }
}
// Global includes
// [BEGIN] HEADERS_GLOBAL
#include "enums/enums_COND.hpp"
#include "enums/enums_POOL.hpp"
#include "enums/enums_KE.hpp"
#include "enums/enums_MOD.hpp"
#include "enums/enums_RC.hpp"
#include "enums/enums_VARS.hpp"
#include "enums/enums_VEL.hpp"
// [END] HEADERS_GLOBAL

// Specializations for get_enum_names
// [BEGIN] HEADERS_NAMES
#include "enums/enums_COND_names.hpp"
#include "enums/enums_POOL_names.hpp"
#include "enums/enums_KE_names.hpp"
#include "enums/enums_MOD_names.hpp"
#include "enums/enums_RC_names.hpp"
#include "enums/enums_VARS_names.hpp"
#include "enums/enums_VEL_names.hpp"
// [END] HEADERS_NAMES

// Specializations for get_enum_values
// [BEGIN] HEADERS_VALUES
#include "enums/enums_COND_defaults.hpp"
#include "enums/enums_POOL_defaults.hpp"
#include "enums/enums_KE_defaults.hpp"
#include "enums/enums_MOD_defaults.hpp"
#include "enums/enums_RC_defaults.hpp"
#include "enums/enums_VARS_defaults.hpp"
#include "enums/enums_VEL_defaults.hpp"
// [END] HEADERS_VALUES

// Specializations for get_enum_alternate_values
// [BEGIN] HEADERS_ALTERNATE_VALUES
#include "enums/enums_COND_defaults_C3.hpp"
#include "enums/enums_POOL_defaults_C3.hpp"
#include "enums/enums_KE_defaults_C3.hpp"
#include "enums/enums_MOD_defaults_C3.hpp"
#include "enums/enums_RC_defaults_C3.hpp"
#include "enums/enums_VARS_defaults_C3.hpp"
#include "enums/enums_VEL_defaults_C3.hpp"
// [END] HEADERS_ALTERNATE_VALUES

// Specializations for get_enum_glymaids
// [BEGIN] HEADERS_GLYMAIDS
#include "enums/enums_COND_glymaids.hpp"
#include "enums/enums_POOL_glymaids.hpp"
#include "enums/enums_KE_glymaids.hpp"
#include "enums/enums_MOD_glymaids.hpp"
#include "enums/enums_RC_glymaids.hpp"
#include "enums/enums_VARS_glymaids.hpp"
#include "enums/enums_VEL_glymaids.hpp"
// [END] HEADERS_GLYMAIDS

// Specializations for get_enum_aliases
// [BEGIN] HEADERS_ALIASES
#include "enums/enums_COND_aliases.hpp"
#include "enums/enums_POOL_aliases.hpp"
#include "enums/enums_KE_aliases.hpp"
#include "enums/enums_MOD_aliases.hpp"
#include "enums/enums_RC_aliases.hpp"
#include "enums/enums_VARS_aliases.hpp"
#include "enums/enums_VEL_aliases.hpp"
// [END] HEADERS_ALIASES

// Specializations for get_enum_docs
// [BEGIN] HEADERS_DOCS
#include "enums/enums_COND_docs.hpp"
#include "enums/enums_POOL_docs.hpp"
#include "enums/enums_KE_docs.hpp"
#include "enums/enums_MOD_docs.hpp"
#include "enums/enums_RC_docs.hpp"
#include "enums/enums_VARS_docs.hpp"
#include "enums/enums_VEL_docs.hpp"
// [END] HEADERS_DOCS

// Specializations for get_enum_value_flags
// [BEGIN] HEADERS_VALUE_FLAGS
#include "enums/enums_COND_value_flags.hpp"
#include "enums/enums_POOL_value_flags.hpp"
#include "enums/enums_KE_value_flags.hpp"
#include "enums/enums_MOD_value_flags.hpp"
#include "enums/enums_RC_value_flags.hpp"
#include "enums/enums_VARS_value_flags.hpp"
#include "enums/enums_VEL_value_flags.hpp"
// [END] HEADERS_VALUE_FLAGS

// Specializations for get_enum_static_value_flags
// [BEGIN] HEADERS_STATIC_VALUE_FLAGS
#include "enums/enums_COND_static_value_flags.hpp"
#include "enums/enums_POOL_static_value_flags.hpp"
#include "enums/enums_KE_static_value_flags.hpp"
#include "enums/enums_MOD_static_value_flags.hpp"
#include "enums/enums_RC_static_value_flags.hpp"
#include "enums/enums_VARS_static_value_flags.hpp"
#include "enums/enums_VEL_static_value_flags.hpp"
// [END] HEADERS_STATIC_VALUE_FLAGS

