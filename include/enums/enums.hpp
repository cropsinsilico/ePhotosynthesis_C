// This code is generated by generate_enum.py and should not be
// modified directly
#pragma once

#include <string>
#include <map>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
namespace ePhotosynthesis {
  enum MODULE : int {
      MODULE_NONE       ,
      MODULE_BF         ,
      MODULE_FI         ,
      MODULE_PR         ,
      MODULE_PS         ,
      MODULE_RROEA      ,
      MODULE_RuACT      ,
      MODULE_SUCS       ,
      MODULE_XanCycle   ,
      MODULE_FIBF       ,
      MODULE_RedoxReg   ,
      MODULE_CM         ,
      MODULE_DynaPS     ,
      MODULE_EPS        ,
      MODULE_RA         ,
      MODULE_trDynaPS   ,
      MODULE_PS_PR      ,
      MODULE_MAX        ,
  };
  
  enum PARAM_TYPE : int {
      PARAM_TYPE_NONE   ,
      PARAM_TYPE_COND   ,
      PARAM_TYPE_POOL   ,
      PARAM_TYPE_KE     ,
      PARAM_TYPE_MOD    ,
      PARAM_TYPE_RC     ,
      PARAM_TYPE_MAX    ,
  };
  
  // Utility for getting module id from enum type
  template<typename T>
  MODULE get_enum_module() {
    return T::MODULE;
  }
  
  // Utility for getting param_type from enum type
  template<typename T>
  PARAM_TYPE get_enum_param_type() {
    return T::PARAM_TYPE;
  }
  
  // Utility for getting names from enum
  template<typename T>
  const std::map<T, std::string>& get_enum_names() {
    static const std::map<T, std::string> result;
    throw std::runtime_error("No enum names collection could be found");
    return result;
  }
  template<>
  inline const std::map<MODULE, std::string>& get_enum_names<MODULE>() {
    static const std::map<MODULE, std::string> collection = {
      {MODULE_BF      , "BF"      },
      {MODULE_FI      , "FI"      },
      {MODULE_PR      , "PR"      },
      {MODULE_PS      , "PS"      },
      {MODULE_RROEA   , "RROEA"   },
      {MODULE_RuACT   , "RuACT"   },
      {MODULE_SUCS    , "SUCS"    },
      {MODULE_XanCycle, "XanCycle"},
      {MODULE_FIBF    , "FIBF"    },
      {MODULE_RedoxReg, "RedoxReg"},
      {MODULE_CM      , "CM"      },
      {MODULE_DynaPS  , "DynaPS"  },
      {MODULE_EPS     , "EPS"     },
      {MODULE_RA      , "RA"      },
      {MODULE_trDynaPS, "trDynaPS"},
      {MODULE_PS_PR   , "PS_PR"   },
    };
    return collection;
  }
  template<>
  inline const std::map<PARAM_TYPE, std::string>& get_enum_names<PARAM_TYPE>() {
    static const std::map<PARAM_TYPE, std::string> collection = {
      {PARAM_TYPE_COND, "COND"},
      {PARAM_TYPE_POOL, "POOL"},
      {PARAM_TYPE_KE  , "KE"  },
      {PARAM_TYPE_MOD , "MOD" },
      {PARAM_TYPE_RC  , "RC"  },
    };
    return collection;
  }
  // Utility for getting values from enum
  template<typename T>
  const std::map<T, double>& get_enum_defaults() {
    static const std::map<T, double> result;
    throw std::runtime_error("No enum defaults collection could be found");
    return result;
  }
  // Utility for getting alternate_values from enum
  template<typename T>
  const std::map<T, double>& get_enum_defaults_C3() {
    static const std::map<T, double> result;
    throw std::runtime_error("No enum defaults_C3 collection could be found");
    return result;
  }
  // Utility for getting glymaids from enum
  template<typename T>
  const std::map<T, std::string>& get_enum_glymaids() {
    static const std::map<T, std::string> result;
    throw std::runtime_error("No enum glymaids collection could be found");
    return result;
  }
  // Utility for getting constant from enum
  template<typename T>
  const std::vector<T>& get_enum_constant() {
    static const std::vector<T> result;
    throw std::runtime_error("No enum constant collection could be found");
    return result;
  }
  // Utility for getting calculated from enum
  template<typename T>
  const std::vector<T>& get_enum_calculated() {
    static const std::vector<T> result;
    throw std::runtime_error("No enum calculated collection could be found");
    return result;
  }
  // Utility for getting nonvector from enum
  template<typename T>
  const std::vector<T>& get_enum_nonvector() {
    static const std::vector<T> result;
    throw std::runtime_error("No enum nonvector collection could be found");
    return result;
  }
  // Utility for getting skipped from enum
  template<typename T>
  std::vector<T>& get_enum_skipped() {
    static std::vector<T> result;
    throw std::runtime_error("No enum skipped collection could be found");
    return result;
  }
  // Utility for getting resetone from enum
  template<typename T>
  const std::vector<T>& get_enum_resetone() {
    static const std::vector<T> result;
    throw std::runtime_error("No enum resetone collection could be found");
    return result;
  }
  // Utility for getting initonce from enum
  template<typename T>
  const std::vector<T>& get_enum_initonce() {
    static const std::vector<T> result;
    throw std::runtime_error("No enum initonce collection could be found");
    return result;
  }
  // Unspecialized enum
  template<MODULE M, PARAM_TYPE PT>
  class ValueSetEnum {
  public:
    enum Type : int;
    static const MODULE module;
    static const PARAM_TYPE param_type;
    static const std::vector<Type> all;  /**< All enum values */
    static bool state_updated;  /** One of the editable collection(s) was updated */
    static const std::map<Type, std::string> names;  /**< Names for values */
    static const std::map<Type, double> defaults;  /**< Defaults for values */
    static const std::map<Type, double> defaults_C3;  /**< Defaults_C3 for values */
    static const std::map<Type, std::string> glymaids;  /**< Glymaids for values */
    static const std::vector<Type> constant;  /**< Values that are constant */
    static const std::vector<Type> calculated;  /**< Values that are calculated */
    static const std::vector<Type> nonvector;  /**< Values that are nonvector */
    static std::vector<Type> skipped;  /**< Values that are skipped */
    static const std::vector<Type> resetone;  /**< Values that are resetone */
    static const std::vector<Type> initonce;  /**< Values that are initonce */
    /**
      Get a prefix for errors describing the class
      \return Prefix
    */
    static std::string error_prefix() {
      std::string out;
      out += get_enum_names<PARAM_TYPE>().find(param_type)->second;
      out += "[";
      out += get_enum_names<MODULE>().find(module)->second;
      out += "]: ";
      return out;
    }
    /**
      Serialize an enum to an output stream
      \param[in,out] out Output stream
      \param[in] x Key to serialize
      \return Updated stream
    */
    friend std::ostream& operator<<(std::ostream& out, const Type& x) {
      out << getName(x);
      return out;
    }
    /**
      Serialize an enum to an output stream
      \param[in,out] out Output stream
      \param[in] x Collection to serialize
      \return Updated stream
    */
    friend std::ostream& operator<<(std::ostream& out, const std::map<Type, std::string>& x) {
      print_map(x, out);
      return out;
    }
    /**
      Get the name value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static std::string getName(const Type& x) {
      typename std::map<Type, std::string>::const_iterator it;
      it = names.find(x);
      if (it == names.end()) {
        throw std::runtime_error("Could not locate Name for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the name value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static std::string getName(const Type& x, const std::string& defaultV) {
      typename std::map<Type, std::string>::const_iterator it;
      it = names.find(x);
      if (it == names.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of a collection
      \param[in] collection Object to print
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& print_map(const std::map<Type, double>& collection, std::ostream& out, const unsigned int tab = 0) {
      const std::string space(tab * 4, ' ');
      out << space << "{" << std::endl;;
      typename std::map<Type, double>::const_iterator it;
      for (it = collection.begin(); it != collection.end(); it++) {
        out << space << "  " << names.find(it->first)->second << " = " << it->second << std::endl;
      }
      out << space << "}";
      out << std::endl;
      return out;
    }
    /**
      Serialize a collection to a string
      \param[in] collection Object to serialize
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string string_map(const std::map<Type, double>& collection, const unsigned int tab = 0) {
      std::ostringstream oss;
      print_map(collection, oss, tab);
      return oss.str();
    }
    /**
      Print the contents of defaults
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printDefaults(std::ostream& out, const unsigned int tab = 0) {
      return print_map(defaults, out, tab);
    }
    /**
      Serialize the contents of defaults
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringDefaults(const unsigned int tab = 0) {
      return string_map(defaults, tab);
    }
    /**
      Get the default value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static double getDefault(const Type& x) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults.find(x);
      if (it == defaults.end()) {
        throw std::runtime_error("Could not locate Default for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the default value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static double getDefault(const Type& x, const double& defaultV) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults.find(x);
      if (it == defaults.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of defaults_C3
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printDefaults_C3(std::ostream& out, const unsigned int tab = 0) {
      return print_map(defaults_C3, out, tab);
    }
    /**
      Serialize the contents of defaults_C3
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringDefaults_C3(const unsigned int tab = 0) {
      return string_map(defaults_C3, tab);
    }
    /**
      Get the default_c3 value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static double getDefault_C3(const Type& x) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults_C3.find(x);
      if (it == defaults_C3.end()) {
        throw std::runtime_error("Could not locate Default_C3 for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the default_c3 value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static double getDefault_C3(const Type& x, const double& defaultV) {
      typename std::map<Type, double>::const_iterator it;
      it = defaults_C3.find(x);
      if (it == defaults_C3.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of glymaids
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printGlymaids(std::ostream& out, const unsigned int tab = 0) {
      return print_map(glymaids, out, tab);
    }
    /**
      Serialize the contents of glymaids
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringGlymaids(const unsigned int tab = 0) {
      return string_map(glymaids, tab);
    }
    /**
      Get the glymaid value corresponding to an enum key
      \param[in] x Key to get value for
      \return Value
    */
    static std::string getGlymaid(const Type& x) {
      typename std::map<Type, std::string>::const_iterator it;
      it = glymaids.find(x);
      if (it == glymaids.end()) {
        throw std::runtime_error("Could not locate Glymaid for '" + names.find(x)->second + "'");
      }
      return it->second;
    }
    /**
      Get the glymaid value corresponding to an enum key
      \param[in] x Key to get value for
      \param[in] defaultV Value to return if x is not present
      \return Value
    */
    static std::string getGlymaid(const Type& x, const std::string& defaultV) {
      typename std::map<Type, std::string>::const_iterator it;
      it = glymaids.find(x);
      if (it == glymaids.end()) {
        return defaultV;
      }
      return it->second;
    }
    /**
      Print the contents of a collection
      \param[in] collection Object to print
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& print_vector(const std::vector<Type>& collection, std::ostream& out, const unsigned int tab = 0) {
      const std::string space(tab * 4, ' ');
      out << space << "[";
      typename std::vector<Type>::const_iterator it;
      for (it = collection.begin(); it != collection.end(); it++) {
        out << names.find((*(it)))->second << ",";
      }
      out << "]";
      out << std::endl;
      return out;
    }
    /**
      Serialize a collection to a string
      \param[in] collection Object to serialize
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string string_vector(const std::vector<Type>& collection, const unsigned int tab = 0) {
      std::ostringstream oss;
      print_vector(collection, oss, tab);
      return oss.str();
    }
    /**
      Serialize an enum to an output stream
      \param[in,out] out Output stream
      \param[in] x Collection to serialize
      \return Updated stream
    */
    friend std::ostream& operator<<(std::ostream& out, const std::vector<Type>& x) {
      print_vector(x, out);
      return out;
    }
    /**
      Print the contents of constant
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printConstant(std::ostream& out, const unsigned int tab = 0) {
      return print_vector(constant, out, tab);
    }
    /**
      Serialize the contents of constant
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringConstant(const unsigned int tab = 0) {
      return string_vector(constant, tab);
    }
    /**
      Check if a key is in constant
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isConstant(const Type& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = constant.begin(); it != constant.end(); it++){
        if ((*(it)) == x) break;
      }
      return (it != constant.end());
    }
    /**
      Throw an error if a key is not in constant
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkConstant(const Type& x, const std::string& context = "") {
      if (!isConstant(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in constant");
      }
    }
    /**
      Throw an error if a key is in constant
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotConstant(const Type& x, const std::string& context = "") {
      if (isConstant(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in constant");
      }
    }
    /**
      Print the contents of calculated
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printCalculated(std::ostream& out, const unsigned int tab = 0) {
      return print_vector(calculated, out, tab);
    }
    /**
      Serialize the contents of calculated
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringCalculated(const unsigned int tab = 0) {
      return string_vector(calculated, tab);
    }
    /**
      Check if a key is in calculated
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isCalculated(const Type& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = calculated.begin(); it != calculated.end(); it++){
        if ((*(it)) == x) break;
      }
      return (it != calculated.end());
    }
    /**
      Throw an error if a key is not in calculated
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkCalculated(const Type& x, const std::string& context = "") {
      if (!isCalculated(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in calculated");
      }
    }
    /**
      Throw an error if a key is in calculated
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotCalculated(const Type& x, const std::string& context = "") {
      if (isCalculated(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in calculated");
      }
    }
    /**
      Print the contents of nonvector
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printNonvector(std::ostream& out, const unsigned int tab = 0) {
      return print_vector(nonvector, out, tab);
    }
    /**
      Serialize the contents of nonvector
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringNonvector(const unsigned int tab = 0) {
      return string_vector(nonvector, tab);
    }
    /**
      Check if a key is in nonvector
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isNonvector(const Type& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = nonvector.begin(); it != nonvector.end(); it++){
        if ((*(it)) == x) break;
      }
      return (it != nonvector.end());
    }
    /**
      Throw an error if a key is not in nonvector
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNonvector(const Type& x, const std::string& context = "") {
      if (!isNonvector(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in nonvector");
      }
    }
    /**
      Throw an error if a key is in nonvector
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotNonvector(const Type& x, const std::string& context = "") {
      if (isNonvector(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in nonvector");
      }
    }
    /**
      Print the contents of skipped
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printSkipped(std::ostream& out, const unsigned int tab = 0) {
      return print_vector(skipped, out, tab);
    }
    /**
      Serialize the contents of skipped
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringSkipped(const unsigned int tab = 0) {
      return string_vector(skipped, tab);
    }
    /**
      Check if a key is in skipped
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isSkipped(const Type& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = skipped.begin(); it != skipped.end(); it++){
        if ((*(it)) == x) break;
      }
      return (it != skipped.end());
    }
    /**
      Throw an error if a key is not in skipped
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkSkipped(const Type& x, const std::string& context = "") {
      if (!isSkipped(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in skipped");
      }
    }
    /**
      Throw an error if a key is in skipped
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotSkipped(const Type& x, const std::string& context = "") {
      if (isSkipped(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in skipped");
      }
    }
    /**
      Remove all entries from skipped
    */
    static void clearSkipped() {
      skipped.clear();
      state_updated = true;
    }
    /**
      Add an element to skipped if it is not already present
      \param[in] x Key to add
    */
    static void addSkipped(const Type& x) {
      if (!isSkipped(x)) {
        skipped.push_back(x);
      }
      state_updated = true;
    }
    /**
      Remove an element from skipped
      \param[in] x Key to remove
    */
    static void removeSkipped(const Type& x) {
      typename std::vector<Type>::iterator it;
      for (it = skipped.begin(); it != skipped.end(); it++){
        if ((*(it)) == x) break;
      }
      if (it != skipped.end()) {
        skipped.erase(it);
      }
      state_updated = true;
    }
    /**
      Add multiple elements to skipped if they are not already present
      \param[in] x Elements to add
    */
    static void addMultipleSkipped(const std::vector<Type>& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = x.begin(); it != x.end(); it++) {
        addSkipped((*(it)));
      }
      state_updated = true;
    }
    /**
      Remove multiple elements to skipped if they are not already present
      \param[in] x Elements to add
    */
    static void removeMultipleSkipped(const std::vector<Type>& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = x.begin(); it != x.end(); it++) {
        removeSkipped((*(it)));
      }
      state_updated = true;
    }
    /**
      Print the contents of resetone
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printResetone(std::ostream& out, const unsigned int tab = 0) {
      return print_vector(resetone, out, tab);
    }
    /**
      Serialize the contents of resetone
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringResetone(const unsigned int tab = 0) {
      return string_vector(resetone, tab);
    }
    /**
      Check if a key is in resetone
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isResetone(const Type& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = resetone.begin(); it != resetone.end(); it++){
        if ((*(it)) == x) break;
      }
      return (it != resetone.end());
    }
    /**
      Throw an error if a key is not in resetone
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkResetone(const Type& x, const std::string& context = "") {
      if (!isResetone(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in resetone");
      }
    }
    /**
      Throw an error if a key is in resetone
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotResetone(const Type& x, const std::string& context = "") {
      if (isResetone(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in resetone");
      }
    }
    /**
      Print the contents of initonce
      \param[in,out] out Stream to print to
      \param[in] tab Indentation to add to each line
      \return Updated stream
    */
    static std::ostream& printInitonce(std::ostream& out, const unsigned int tab = 0) {
      return print_vector(initonce, out, tab);
    }
    /**
      Serialize the contents of initonce
      \param[in] tab Indentation to add to each line
      \return Serialized collection
    */
    static std::string stringInitonce(const unsigned int tab = 0) {
      return string_vector(initonce, tab);
    }
    /**
      Check if a key is in initonce
      \param[in] x Key to check
      \return true if x is present, false otherwise
    */
    static bool isInitonce(const Type& x) {
      typename std::vector<Type>::const_iterator it;
      for (it = initonce.begin(); it != initonce.end(); it++){
        if ((*(it)) == x) break;
      }
      return (it != initonce.end());
    }
    /**
      Throw an error if a key is not in initonce
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkInitonce(const Type& x, const std::string& context = "") {
      if (!isInitonce(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is not in initonce");
      }
    }
    /**
      Throw an error if a key is in initonce
      \param[in] x Key to check
      \param[in] context String describing context that 
        should be used in the error message
    */
    static void checkNotInitonce(const Type& x, const std::string& context = "") {
      if (isInitonce(x)) {
        throw std::runtime_error(error_prefix() + context + ": '" + names.find(x)->second + "' is in initonce");
      }
    }
  };
  template<MODULE M, PARAM_TYPE PT>
  const MODULE ValueSetEnum<M, PT>::module = M;
  template<MODULE M, PARAM_TYPE PT>
  const PARAM_TYPE ValueSetEnum<M, PT>::param_type = PT;
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, std::string> ValueSetEnum<M, PT>::names = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, double> ValueSetEnum<M, PT>::defaults = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, double> ValueSetEnum<M, PT>::defaults_C3 = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::map<typename ValueSetEnum<M, PT>::Type, std::string> ValueSetEnum<M, PT>::glymaids = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::constant = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::calculated = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::nonvector = {};
  template<MODULE M, PARAM_TYPE PT>
  std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::skipped = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::resetone = {};
  template<MODULE M, PARAM_TYPE PT>
  const std::vector<typename ValueSetEnum<M, PT>::Type> ValueSetEnum<M, PT>::initonce = {};
  
  #include "enums/enums_POOL.hpp"
  #include "enums/enums_COND.hpp"
  #include "enums/enums_KE.hpp"
  #include "enums/enums_RC.hpp"
  #include "enums/enums_MOD.hpp"
  
  // Specializations for get_enum_names
  #include "enums/enums_POOL_names.hpp"
  #include "enums/enums_COND_names.hpp"
  #include "enums/enums_KE_names.hpp"
  #include "enums/enums_RC_names.hpp"
  #include "enums/enums_MOD_names.hpp"
  
  // Specializations for get_enum_values
  #include "enums/enums_POOL_defaults.hpp"
  #include "enums/enums_COND_defaults.hpp"
  #include "enums/enums_KE_defaults.hpp"
  #include "enums/enums_RC_defaults.hpp"
  #include "enums/enums_MOD_defaults.hpp"
  
  // Specializations for get_enum_alternate_values
  #include "enums/enums_COND_defaults_C3.hpp"
  #include "enums/enums_POOL_defaults_C3.hpp"
  #include "enums/enums_KE_defaults_C3.hpp"
  #include "enums/enums_MOD_defaults_C3.hpp"
  #include "enums/enums_RC_defaults_C3.hpp"
  
  // Specializations for get_enum_glymaids
  #include "enums/enums_COND_glymaids.hpp"
  #include "enums/enums_POOL_glymaids.hpp"
  #include "enums/enums_KE_glymaids.hpp"
  #include "enums/enums_MOD_glymaids.hpp"
  #include "enums/enums_RC_glymaids.hpp"
  
  // Specializations for get_enum_constant
  #include "enums/enums_COND_constant.hpp"
  #include "enums/enums_POOL_constant.hpp"
  #include "enums/enums_KE_constant.hpp"
  #include "enums/enums_MOD_constant.hpp"
  #include "enums/enums_RC_constant.hpp"
  
  // Specializations for get_enum_calculated
  #include "enums/enums_COND_calculated.hpp"
  #include "enums/enums_POOL_calculated.hpp"
  #include "enums/enums_KE_calculated.hpp"
  #include "enums/enums_MOD_calculated.hpp"
  #include "enums/enums_RC_calculated.hpp"
  
  // Specializations for get_enum_nonvector
  #include "enums/enums_COND_nonvector.hpp"
  #include "enums/enums_POOL_nonvector.hpp"
  #include "enums/enums_KE_nonvector.hpp"
  #include "enums/enums_MOD_nonvector.hpp"
  #include "enums/enums_RC_nonvector.hpp"
  
  // Specializations for get_enum_skipped
  #include "enums/enums_COND_skipped.hpp"
  #include "enums/enums_POOL_skipped.hpp"
  #include "enums/enums_KE_skipped.hpp"
  #include "enums/enums_MOD_skipped.hpp"
  #include "enums/enums_RC_skipped.hpp"
  
  // Specializations for get_enum_resetone
  #include "enums/enums_COND_resetone.hpp"
  #include "enums/enums_POOL_resetone.hpp"
  #include "enums/enums_KE_resetone.hpp"
  #include "enums/enums_MOD_resetone.hpp"
  #include "enums/enums_RC_resetone.hpp"
  
  // Specializations for get_enum_initonce
  #include "enums/enums_COND_initonce.hpp"
  #include "enums/enums_POOL_initonce.hpp"
  #include "enums/enums_KE_initonce.hpp"
  #include "enums/enums_MOD_initonce.hpp"
  #include "enums/enums_RC_initonce.hpp"
  
  
  // Utility for getting enum type from module & param_type
  #define MODULE2Enum ValueSetEnum
  // Code after this line will be preserved
}
