// This code is generated by generate_enum.py and should not be
// modified directly
#pragma once

#include "enums/enums_helpers.hpp"

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_BF
  };
  typedef typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type ENUM_BF_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_BF_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_BF_MOD> {
    typedef ENUM_BF_MOD type;
    static const MODULE module = MODULE_BF;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_BF, PARAM_TYPE_MOD> BF;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_CM
  };
  typedef typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type ENUM_CM_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_CM_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_CM_MOD> {
    typedef ENUM_CM_MOD type;
    static const MODULE module = MODULE_CM;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_CM, PARAM_TYPE_MOD> CM;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_DynaPS
  };
  typedef typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type ENUM_DynaPS_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_DynaPS_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_DynaPS_MOD> {
    typedef ENUM_DynaPS_MOD type;
    static const MODULE module = MODULE_DynaPS;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_DynaPS, PARAM_TYPE_MOD> DynaPS;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_EPS
  };
  typedef typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type ENUM_EPS_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_EPS_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_EPS_MOD> {
    typedef ENUM_EPS_MOD type;
    static const MODULE module = MODULE_EPS;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_EPS, PARAM_TYPE_MOD> EPS;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_FIBF
  };
  typedef typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type ENUM_FIBF_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_FIBF_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_FIBF_MOD> {
    typedef ENUM_FIBF_MOD type;
    static const MODULE module = MODULE_FIBF;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_FIBF, PARAM_TYPE_MOD> FIBF;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_FI
  };
  typedef typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type ENUM_FI_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_FI_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_FI_MOD> {
    typedef ENUM_FI_MOD type;
    static const MODULE module = MODULE_FI;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_FI, PARAM_TYPE_MOD> FI;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_PR
  };
  typedef typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type ENUM_PR_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_PR_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_PR_MOD> {
    typedef ENUM_PR_MOD type;
    static const MODULE module = MODULE_PR;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_PR, PARAM_TYPE_MOD> PR;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_PS
  };
  typedef typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type ENUM_PS_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_PS_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_PS_MOD> {
    typedef ENUM_PS_MOD type;
    static const MODULE module = MODULE_PS;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_PS, PARAM_TYPE_MOD> PS;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_PS_PR
  };
  typedef typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type ENUM_PS_PR_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_PS_PR_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_PS_PR_MOD> {
    typedef ENUM_PS_PR_MOD type;
    static const MODULE module = MODULE_PS_PR;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_PS_PR, PARAM_TYPE_MOD> PS_PR;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_RA
  };
  typedef typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type ENUM_RA_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_RA_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_RA_MOD> {
    typedef ENUM_RA_MOD type;
    static const MODULE module = MODULE_RA;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_RA, PARAM_TYPE_MOD> RA;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_RROEA
  };
  typedef typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type ENUM_RROEA_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_RROEA_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_RROEA_MOD> {
    typedef ENUM_RROEA_MOD type;
    static const MODULE module = MODULE_RROEA;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_RROEA, PARAM_TYPE_MOD> RROEA;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_RedoxReg
  };
  typedef typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type ENUM_RedoxReg_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_RedoxReg_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_RedoxReg_MOD> {
    typedef ENUM_RedoxReg_MOD type;
    static const MODULE module = MODULE_RedoxReg;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_RedoxReg, PARAM_TYPE_MOD> RedoxReg;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_RuACT
  };
  typedef typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type ENUM_RuACT_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_RuACT_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_RuACT_MOD> {
    typedef ENUM_RuACT_MOD type;
    static const MODULE module = MODULE_RuACT;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_RuACT, PARAM_TYPE_MOD> RuACT;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_SUCS
  };
  typedef typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type ENUM_SUCS_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_SUCS_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_SUCS_MOD> {
    typedef ENUM_SUCS_MOD type;
    static const MODULE module = MODULE_SUCS;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_SUCS, PARAM_TYPE_MOD> SUCS;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_XanCycle
  };
  typedef typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type ENUM_XanCycle_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_XanCycle_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_XanCycle_MOD> {
    typedef ENUM_XanCycle_MOD type;
    static const MODULE module = MODULE_XanCycle;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_XanCycle, PARAM_TYPE_MOD> XanCycle;
  }
}

namespace ePhotosynthesis {
  #ifndef EPHOTO_USE_SCOPED_ENUM
  template<>
  enum ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type : int {
    MEMBERS_trDynaPS
  };
  typedef typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type ENUM_trDynaPS_MOD;
  #endif  // EPHOTO_USE_SCOPED_ENUM
  template<>
  const std::vector<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::all;
  template<>
  const std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::names;
  template<>
  const std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::defaults;
  template<>
  const std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, double> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::defaults_C3;
  template<>
  const std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::glymaids;
  template<>
  const std::map<std::string, typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::aliases;
  template<>
  const std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, std::string> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::docs;
  template<>
  std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::value_flags;
  template<>
  const std::map<typename ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::Type, int> ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD>::static_value_flags;
  EPHOTO_API std::ostream& operator<<(std::ostream& out, const ENUM_trDynaPS_MOD& x);
  template<>
  struct enum_helper_inv<ENUM_trDynaPS_MOD> {
    typedef ENUM_trDynaPS_MOD type;
    static const MODULE module = MODULE_trDynaPS;
    static const PARAM_TYPE param_type = PARAM_TYPE_MOD;
  };
  namespace MOD {
    typedef ValueSetEnum<MODULE_trDynaPS, PARAM_TYPE_MOD> trDynaPS;
  }
}


